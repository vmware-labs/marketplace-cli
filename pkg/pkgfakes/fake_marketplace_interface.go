// Code generated by counterfeiter. DO NOT EDIT.
package pkgfakes

import (
	"io"
	"net/url"
	"sync"

	"github.com/vmware-labs/marketplace-cli/v2/internal"
	"github.com/vmware-labs/marketplace-cli/v2/internal/models"
	"github.com/vmware-labs/marketplace-cli/v2/pkg"
)

type FakeMarketplaceInterface struct {
	AttachLocalChartStub        func(string, string, *models.Product, *models.Version) (*models.Product, error)
	attachLocalChartMutex       sync.RWMutex
	attachLocalChartArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}
	attachLocalChartReturns struct {
		result1 *models.Product
		result2 error
	}
	attachLocalChartReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachLocalContainerImageStub        func(string, string, string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachLocalContainerImageMutex       sync.RWMutex
	attachLocalContainerImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *models.Product
		arg7 *models.Version
	}
	attachLocalContainerImageReturns struct {
		result1 *models.Product
		result2 error
	}
	attachLocalContainerImageReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachMetaFileStub        func(string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachMetaFileMutex       sync.RWMutex
	attachMetaFileArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *models.Product
		arg5 *models.Version
	}
	attachMetaFileReturns struct {
		result1 *models.Product
		result2 error
	}
	attachMetaFileReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachOtherFileStub        func(string, *models.Product, *models.Version) (*models.Product, error)
	attachOtherFileMutex       sync.RWMutex
	attachOtherFileArgsForCall []struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}
	attachOtherFileReturns struct {
		result1 *models.Product
		result2 error
	}
	attachOtherFileReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachPublicChartStub        func(*url.URL, string, *models.Product, *models.Version) (*models.Product, error)
	attachPublicChartMutex       sync.RWMutex
	attachPublicChartArgsForCall []struct {
		arg1 *url.URL
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}
	attachPublicChartReturns struct {
		result1 *models.Product
		result2 error
	}
	attachPublicChartReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachPublicContainerImageStub        func(string, string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachPublicContainerImageMutex       sync.RWMutex
	attachPublicContainerImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.Product
		arg6 *models.Version
	}
	attachPublicContainerImageReturns struct {
		result1 *models.Product
		result2 error
	}
	attachPublicContainerImageReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	DecodeJsonStub        func(io.Reader, interface{}) error
	decodeJsonMutex       sync.RWMutex
	decodeJsonArgsForCall []struct {
		arg1 io.Reader
		arg2 interface{}
	}
	decodeJsonReturns struct {
		result1 error
	}
	decodeJsonReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadStub        func(string, *pkg.DownloadRequestPayload) error
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		arg1 string
		arg2 *pkg.DownloadRequestPayload
	}
	downloadReturns struct {
		result1 error
	}
	downloadReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadChartStub        func(*url.URL) (*models.ChartVersion, error)
	downloadChartMutex       sync.RWMutex
	downloadChartArgsForCall []struct {
		arg1 *url.URL
	}
	downloadChartReturns struct {
		result1 *models.ChartVersion
		result2 error
	}
	downloadChartReturnsOnCall map[int]struct {
		result1 *models.ChartVersion
		result2 error
	}
	EnableStrictDecodingStub        func()
	enableStrictDecodingMutex       sync.RWMutex
	enableStrictDecodingArgsForCall []struct {
	}
	GetAPIHostStub        func() string
	getAPIHostMutex       sync.RWMutex
	getAPIHostArgsForCall []struct {
	}
	getAPIHostReturns struct {
		result1 string
	}
	getAPIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetHostStub        func() string
	getHostMutex       sync.RWMutex
	getHostArgsForCall []struct {
	}
	getHostReturns struct {
		result1 string
	}
	getHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetProductStub        func(string) (*models.Product, error)
	getProductMutex       sync.RWMutex
	getProductArgsForCall []struct {
		arg1 string
	}
	getProductReturns struct {
		result1 *models.Product
		result2 error
	}
	getProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	GetProductWithVersionStub        func(string, string) (*models.Product, *models.Version, error)
	getProductWithVersionMutex       sync.RWMutex
	getProductWithVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getProductWithVersionReturns struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	getProductWithVersionReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	GetUIHostStub        func() string
	getUIHostMutex       sync.RWMutex
	getUIHostArgsForCall []struct {
	}
	getUIHostReturns struct {
		result1 string
	}
	getUIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetUploaderStub        func(string) (internal.Uploader, error)
	getUploaderMutex       sync.RWMutex
	getUploaderArgsForCall []struct {
		arg1 string
	}
	getUploaderReturns struct {
		result1 internal.Uploader
		result2 error
	}
	getUploaderReturnsOnCall map[int]struct {
		result1 internal.Uploader
		result2 error
	}
	ListProductsStub        func(bool, string) ([]*models.Product, error)
	listProductsMutex       sync.RWMutex
	listProductsArgsForCall []struct {
		arg1 bool
		arg2 string
	}
	listProductsReturns struct {
		result1 []*models.Product
		result2 error
	}
	listProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	PutProductStub        func(*models.Product, bool) (*models.Product, error)
	putProductMutex       sync.RWMutex
	putProductArgsForCall []struct {
		arg1 *models.Product
		arg2 bool
	}
	putProductReturns struct {
		result1 *models.Product
		result2 error
	}
	putProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	SetUploaderStub        func(internal.Uploader)
	setUploaderMutex       sync.RWMutex
	setUploaderArgsForCall []struct {
		arg1 internal.Uploader
	}
	UploadVMStub        func(string, *models.Product, *models.Version) (*models.Product, error)
	uploadVMMutex       sync.RWMutex
	uploadVMArgsForCall []struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}
	uploadVMReturns struct {
		result1 *models.Product
		result2 error
	}
	uploadVMReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMarketplaceInterface) AttachLocalChart(arg1 string, arg2 string, arg3 *models.Product, arg4 *models.Version) (*models.Product, error) {
	fake.attachLocalChartMutex.Lock()
	ret, specificReturn := fake.attachLocalChartReturnsOnCall[len(fake.attachLocalChartArgsForCall)]
	fake.attachLocalChartArgsForCall = append(fake.attachLocalChartArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}{arg1, arg2, arg3, arg4})
	stub := fake.AttachLocalChartStub
	fakeReturns := fake.attachLocalChartReturns
	fake.recordInvocation("AttachLocalChart", []interface{}{arg1, arg2, arg3, arg4})
	fake.attachLocalChartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachLocalChartCallCount() int {
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	return len(fake.attachLocalChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachLocalChartCalls(stub func(string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = stub
}

func (fake *FakeMarketplaceInterface) AttachLocalChartArgsForCall(i int) (string, string, *models.Product, *models.Version) {
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	argsForCall := fake.attachLocalChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) AttachLocalChartReturns(result1 *models.Product, result2 error) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = nil
	fake.attachLocalChartReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalChartReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = nil
	if fake.attachLocalChartReturnsOnCall == nil {
		fake.attachLocalChartReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachLocalChartReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImage(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string, arg6 *models.Product, arg7 *models.Version) (*models.Product, error) {
	fake.attachLocalContainerImageMutex.Lock()
	ret, specificReturn := fake.attachLocalContainerImageReturnsOnCall[len(fake.attachLocalContainerImageArgsForCall)]
	fake.attachLocalContainerImageArgsForCall = append(fake.attachLocalContainerImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *models.Product
		arg7 *models.Version
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.AttachLocalContainerImageStub
	fakeReturns := fake.attachLocalContainerImageReturns
	fake.recordInvocation("AttachLocalContainerImage", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.attachLocalContainerImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageCallCount() int {
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	return len(fake.attachLocalContainerImageArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageCalls(stub func(string, string, string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = stub
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageArgsForCall(i int) (string, string, string, string, string, *models.Product, *models.Version) {
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	argsForCall := fake.attachLocalContainerImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageReturns(result1 *models.Product, result2 error) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = nil
	fake.attachLocalContainerImageReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = nil
	if fake.attachLocalContainerImageReturnsOnCall == nil {
		fake.attachLocalContainerImageReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachLocalContainerImageReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachMetaFile(arg1 string, arg2 string, arg3 string, arg4 *models.Product, arg5 *models.Version) (*models.Product, error) {
	fake.attachMetaFileMutex.Lock()
	ret, specificReturn := fake.attachMetaFileReturnsOnCall[len(fake.attachMetaFileArgsForCall)]
	fake.attachMetaFileArgsForCall = append(fake.attachMetaFileArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *models.Product
		arg5 *models.Version
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AttachMetaFileStub
	fakeReturns := fake.attachMetaFileReturns
	fake.recordInvocation("AttachMetaFile", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.attachMetaFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachMetaFileCallCount() int {
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	return len(fake.attachMetaFileArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachMetaFileCalls(stub func(string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = stub
}

func (fake *FakeMarketplaceInterface) AttachMetaFileArgsForCall(i int) (string, string, string, *models.Product, *models.Version) {
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	argsForCall := fake.attachMetaFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeMarketplaceInterface) AttachMetaFileReturns(result1 *models.Product, result2 error) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = nil
	fake.attachMetaFileReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachMetaFileReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = nil
	if fake.attachMetaFileReturnsOnCall == nil {
		fake.attachMetaFileReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachMetaFileReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachOtherFile(arg1 string, arg2 *models.Product, arg3 *models.Version) (*models.Product, error) {
	fake.attachOtherFileMutex.Lock()
	ret, specificReturn := fake.attachOtherFileReturnsOnCall[len(fake.attachOtherFileArgsForCall)]
	fake.attachOtherFileArgsForCall = append(fake.attachOtherFileArgsForCall, struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}{arg1, arg2, arg3})
	stub := fake.AttachOtherFileStub
	fakeReturns := fake.attachOtherFileReturns
	fake.recordInvocation("AttachOtherFile", []interface{}{arg1, arg2, arg3})
	fake.attachOtherFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachOtherFileCallCount() int {
	fake.attachOtherFileMutex.RLock()
	defer fake.attachOtherFileMutex.RUnlock()
	return len(fake.attachOtherFileArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachOtherFileCalls(stub func(string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachOtherFileMutex.Lock()
	defer fake.attachOtherFileMutex.Unlock()
	fake.AttachOtherFileStub = stub
}

func (fake *FakeMarketplaceInterface) AttachOtherFileArgsForCall(i int) (string, *models.Product, *models.Version) {
	fake.attachOtherFileMutex.RLock()
	defer fake.attachOtherFileMutex.RUnlock()
	argsForCall := fake.attachOtherFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) AttachOtherFileReturns(result1 *models.Product, result2 error) {
	fake.attachOtherFileMutex.Lock()
	defer fake.attachOtherFileMutex.Unlock()
	fake.AttachOtherFileStub = nil
	fake.attachOtherFileReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachOtherFileReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachOtherFileMutex.Lock()
	defer fake.attachOtherFileMutex.Unlock()
	fake.AttachOtherFileStub = nil
	if fake.attachOtherFileReturnsOnCall == nil {
		fake.attachOtherFileReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachOtherFileReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicChart(arg1 *url.URL, arg2 string, arg3 *models.Product, arg4 *models.Version) (*models.Product, error) {
	fake.attachPublicChartMutex.Lock()
	ret, specificReturn := fake.attachPublicChartReturnsOnCall[len(fake.attachPublicChartArgsForCall)]
	fake.attachPublicChartArgsForCall = append(fake.attachPublicChartArgsForCall, struct {
		arg1 *url.URL
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}{arg1, arg2, arg3, arg4})
	stub := fake.AttachPublicChartStub
	fakeReturns := fake.attachPublicChartReturns
	fake.recordInvocation("AttachPublicChart", []interface{}{arg1, arg2, arg3, arg4})
	fake.attachPublicChartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachPublicChartCallCount() int {
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	return len(fake.attachPublicChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachPublicChartCalls(stub func(*url.URL, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = stub
}

func (fake *FakeMarketplaceInterface) AttachPublicChartArgsForCall(i int) (*url.URL, string, *models.Product, *models.Version) {
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	argsForCall := fake.attachPublicChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) AttachPublicChartReturns(result1 *models.Product, result2 error) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = nil
	fake.attachPublicChartReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicChartReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = nil
	if fake.attachPublicChartReturnsOnCall == nil {
		fake.attachPublicChartReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachPublicChartReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImage(arg1 string, arg2 string, arg3 string, arg4 string, arg5 *models.Product, arg6 *models.Version) (*models.Product, error) {
	fake.attachPublicContainerImageMutex.Lock()
	ret, specificReturn := fake.attachPublicContainerImageReturnsOnCall[len(fake.attachPublicContainerImageArgsForCall)]
	fake.attachPublicContainerImageArgsForCall = append(fake.attachPublicContainerImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.Product
		arg6 *models.Version
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.AttachPublicContainerImageStub
	fakeReturns := fake.attachPublicContainerImageReturns
	fake.recordInvocation("AttachPublicContainerImage", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.attachPublicContainerImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageCallCount() int {
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	return len(fake.attachPublicContainerImageArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageCalls(stub func(string, string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = stub
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageArgsForCall(i int) (string, string, string, string, *models.Product, *models.Version) {
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	argsForCall := fake.attachPublicContainerImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageReturns(result1 *models.Product, result2 error) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = nil
	fake.attachPublicContainerImageReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = nil
	if fake.attachPublicContainerImageReturnsOnCall == nil {
		fake.attachPublicContainerImageReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachPublicContainerImageReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) DecodeJson(arg1 io.Reader, arg2 interface{}) error {
	fake.decodeJsonMutex.Lock()
	ret, specificReturn := fake.decodeJsonReturnsOnCall[len(fake.decodeJsonArgsForCall)]
	fake.decodeJsonArgsForCall = append(fake.decodeJsonArgsForCall, struct {
		arg1 io.Reader
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.DecodeJsonStub
	fakeReturns := fake.decodeJsonReturns
	fake.recordInvocation("DecodeJson", []interface{}{arg1, arg2})
	fake.decodeJsonMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DecodeJsonCallCount() int {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	return len(fake.decodeJsonArgsForCall)
}

func (fake *FakeMarketplaceInterface) DecodeJsonCalls(stub func(io.Reader, interface{}) error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = stub
}

func (fake *FakeMarketplaceInterface) DecodeJsonArgsForCall(i int) (io.Reader, interface{}) {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	argsForCall := fake.decodeJsonArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturns(result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	fake.decodeJsonReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturnsOnCall(i int, result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	if fake.decodeJsonReturnsOnCall == nil {
		fake.decodeJsonReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decodeJsonReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) Download(arg1 string, arg2 *pkg.DownloadRequestPayload) error {
	fake.downloadMutex.Lock()
	ret, specificReturn := fake.downloadReturnsOnCall[len(fake.downloadArgsForCall)]
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		arg1 string
		arg2 *pkg.DownloadRequestPayload
	}{arg1, arg2})
	stub := fake.DownloadStub
	fakeReturns := fake.downloadReturns
	fake.recordInvocation("Download", []interface{}{arg1, arg2})
	fake.downloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadCalls(stub func(string, *pkg.DownloadRequestPayload) error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadArgsForCall(i int) (string, *pkg.DownloadRequestPayload) {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	argsForCall := fake.downloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) DownloadReturns(result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadReturnsOnCall(i int, result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	if fake.downloadReturnsOnCall == nil {
		fake.downloadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadChart(arg1 *url.URL) (*models.ChartVersion, error) {
	fake.downloadChartMutex.Lock()
	ret, specificReturn := fake.downloadChartReturnsOnCall[len(fake.downloadChartArgsForCall)]
	fake.downloadChartArgsForCall = append(fake.downloadChartArgsForCall, struct {
		arg1 *url.URL
	}{arg1})
	stub := fake.DownloadChartStub
	fakeReturns := fake.downloadChartReturns
	fake.recordInvocation("DownloadChart", []interface{}{arg1})
	fake.downloadChartMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) DownloadChartCallCount() int {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	return len(fake.downloadChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadChartCalls(stub func(*url.URL) (*models.ChartVersion, error)) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadChartArgsForCall(i int) *url.URL {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	argsForCall := fake.downloadChartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) DownloadChartReturns(result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	fake.downloadChartReturns = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) DownloadChartReturnsOnCall(i int, result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	if fake.downloadChartReturnsOnCall == nil {
		fake.downloadChartReturnsOnCall = make(map[int]struct {
			result1 *models.ChartVersion
			result2 error
		})
	}
	fake.downloadChartReturnsOnCall[i] = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) EnableStrictDecoding() {
	fake.enableStrictDecodingMutex.Lock()
	fake.enableStrictDecodingArgsForCall = append(fake.enableStrictDecodingArgsForCall, struct {
	}{})
	stub := fake.EnableStrictDecodingStub
	fake.recordInvocation("EnableStrictDecoding", []interface{}{})
	fake.enableStrictDecodingMutex.Unlock()
	if stub != nil {
		fake.EnableStrictDecodingStub()
	}
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCallCount() int {
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	return len(fake.enableStrictDecodingArgsForCall)
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCalls(stub func()) {
	fake.enableStrictDecodingMutex.Lock()
	defer fake.enableStrictDecodingMutex.Unlock()
	fake.EnableStrictDecodingStub = stub
}

func (fake *FakeMarketplaceInterface) GetAPIHost() string {
	fake.getAPIHostMutex.Lock()
	ret, specificReturn := fake.getAPIHostReturnsOnCall[len(fake.getAPIHostArgsForCall)]
	fake.getAPIHostArgsForCall = append(fake.getAPIHostArgsForCall, struct {
	}{})
	stub := fake.GetAPIHostStub
	fakeReturns := fake.getAPIHostReturns
	fake.recordInvocation("GetAPIHost", []interface{}{})
	fake.getAPIHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetAPIHostCallCount() int {
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	return len(fake.getAPIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetAPIHostCalls(stub func() string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturns(result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	fake.getAPIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturnsOnCall(i int, result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	if fake.getAPIHostReturnsOnCall == nil {
		fake.getAPIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getAPIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetHost() string {
	fake.getHostMutex.Lock()
	ret, specificReturn := fake.getHostReturnsOnCall[len(fake.getHostArgsForCall)]
	fake.getHostArgsForCall = append(fake.getHostArgsForCall, struct {
	}{})
	stub := fake.GetHostStub
	fakeReturns := fake.getHostReturns
	fake.recordInvocation("GetHost", []interface{}{})
	fake.getHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetHostCallCount() int {
	fake.getHostMutex.RLock()
	defer fake.getHostMutex.RUnlock()
	return len(fake.getHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetHostCalls(stub func() string) {
	fake.getHostMutex.Lock()
	defer fake.getHostMutex.Unlock()
	fake.GetHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetHostReturns(result1 string) {
	fake.getHostMutex.Lock()
	defer fake.getHostMutex.Unlock()
	fake.GetHostStub = nil
	fake.getHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetHostReturnsOnCall(i int, result1 string) {
	fake.getHostMutex.Lock()
	defer fake.getHostMutex.Unlock()
	fake.GetHostStub = nil
	if fake.getHostReturnsOnCall == nil {
		fake.getHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetProduct(arg1 string) (*models.Product, error) {
	fake.getProductMutex.Lock()
	ret, specificReturn := fake.getProductReturnsOnCall[len(fake.getProductArgsForCall)]
	fake.getProductArgsForCall = append(fake.getProductArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProductStub
	fakeReturns := fake.getProductReturns
	fake.recordInvocation("GetProduct", []interface{}{arg1})
	fake.getProductMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetProductCallCount() int {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	return len(fake.getProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductCalls(stub func(string) (*models.Product, error)) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductArgsForCall(i int) string {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	argsForCall := fake.getProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetProductReturns(result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	fake.getProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	if fake.getProductReturnsOnCall == nil {
		fake.getProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.getProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersion(arg1 string, arg2 string) (*models.Product, *models.Version, error) {
	fake.getProductWithVersionMutex.Lock()
	ret, specificReturn := fake.getProductWithVersionReturnsOnCall[len(fake.getProductWithVersionArgsForCall)]
	fake.getProductWithVersionArgsForCall = append(fake.getProductWithVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetProductWithVersionStub
	fakeReturns := fake.getProductWithVersionReturns
	fake.recordInvocation("GetProductWithVersion", []interface{}{arg1, arg2})
	fake.getProductWithVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCallCount() int {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	return len(fake.getProductWithVersionArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCalls(stub func(string, string) (*models.Product, *models.Version, error)) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionArgsForCall(i int) (string, string) {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	argsForCall := fake.getProductWithVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturns(result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	fake.getProductWithVersionReturns = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturnsOnCall(i int, result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	if fake.getProductWithVersionReturnsOnCall == nil {
		fake.getProductWithVersionReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 *models.Version
			result3 error
		})
	}
	fake.getProductWithVersionReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetUIHost() string {
	fake.getUIHostMutex.Lock()
	ret, specificReturn := fake.getUIHostReturnsOnCall[len(fake.getUIHostArgsForCall)]
	fake.getUIHostArgsForCall = append(fake.getUIHostArgsForCall, struct {
	}{})
	stub := fake.GetUIHostStub
	fakeReturns := fake.getUIHostReturns
	fake.recordInvocation("GetUIHost", []interface{}{})
	fake.getUIHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetUIHostCallCount() int {
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	return len(fake.getUIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUIHostCalls(stub func() string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetUIHostReturns(result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	fake.getUIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUIHostReturnsOnCall(i int, result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	if fake.getUIHostReturnsOnCall == nil {
		fake.getUIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUploader(arg1 string) (internal.Uploader, error) {
	fake.getUploaderMutex.Lock()
	ret, specificReturn := fake.getUploaderReturnsOnCall[len(fake.getUploaderArgsForCall)]
	fake.getUploaderArgsForCall = append(fake.getUploaderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUploaderStub
	fakeReturns := fake.getUploaderReturns
	fake.recordInvocation("GetUploader", []interface{}{arg1})
	fake.getUploaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetUploaderCallCount() int {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	return len(fake.getUploaderArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUploaderCalls(stub func(string) (internal.Uploader, error)) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = stub
}

func (fake *FakeMarketplaceInterface) GetUploaderArgsForCall(i int) string {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	argsForCall := fake.getUploaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetUploaderReturns(result1 internal.Uploader, result2 error) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	fake.getUploaderReturns = struct {
		result1 internal.Uploader
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetUploaderReturnsOnCall(i int, result1 internal.Uploader, result2 error) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	if fake.getUploaderReturnsOnCall == nil {
		fake.getUploaderReturnsOnCall = make(map[int]struct {
			result1 internal.Uploader
			result2 error
		})
	}
	fake.getUploaderReturnsOnCall[i] = struct {
		result1 internal.Uploader
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) ListProducts(arg1 bool, arg2 string) ([]*models.Product, error) {
	fake.listProductsMutex.Lock()
	ret, specificReturn := fake.listProductsReturnsOnCall[len(fake.listProductsArgsForCall)]
	fake.listProductsArgsForCall = append(fake.listProductsArgsForCall, struct {
		arg1 bool
		arg2 string
	}{arg1, arg2})
	stub := fake.ListProductsStub
	fakeReturns := fake.listProductsReturns
	fake.recordInvocation("ListProducts", []interface{}{arg1, arg2})
	fake.listProductsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) ListProductsCallCount() int {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	return len(fake.listProductsArgsForCall)
}

func (fake *FakeMarketplaceInterface) ListProductsCalls(stub func(bool, string) ([]*models.Product, error)) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = stub
}

func (fake *FakeMarketplaceInterface) ListProductsArgsForCall(i int) (bool, string) {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	argsForCall := fake.listProductsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) ListProductsReturns(result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	fake.listProductsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) ListProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	if fake.listProductsReturnsOnCall == nil {
		fake.listProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.listProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProduct(arg1 *models.Product, arg2 bool) (*models.Product, error) {
	fake.putProductMutex.Lock()
	ret, specificReturn := fake.putProductReturnsOnCall[len(fake.putProductArgsForCall)]
	fake.putProductArgsForCall = append(fake.putProductArgsForCall, struct {
		arg1 *models.Product
		arg2 bool
	}{arg1, arg2})
	stub := fake.PutProductStub
	fakeReturns := fake.putProductReturns
	fake.recordInvocation("PutProduct", []interface{}{arg1, arg2})
	fake.putProductMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PutProductCallCount() int {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	return len(fake.putProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) PutProductCalls(stub func(*models.Product, bool) (*models.Product, error)) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = stub
}

func (fake *FakeMarketplaceInterface) PutProductArgsForCall(i int) (*models.Product, bool) {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	argsForCall := fake.putProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) PutProductReturns(result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	fake.putProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	if fake.putProductReturnsOnCall == nil {
		fake.putProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.putProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SetUploader(arg1 internal.Uploader) {
	fake.setUploaderMutex.Lock()
	fake.setUploaderArgsForCall = append(fake.setUploaderArgsForCall, struct {
		arg1 internal.Uploader
	}{arg1})
	stub := fake.SetUploaderStub
	fake.recordInvocation("SetUploader", []interface{}{arg1})
	fake.setUploaderMutex.Unlock()
	if stub != nil {
		fake.SetUploaderStub(arg1)
	}
}

func (fake *FakeMarketplaceInterface) SetUploaderCallCount() int {
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	return len(fake.setUploaderArgsForCall)
}

func (fake *FakeMarketplaceInterface) SetUploaderCalls(stub func(internal.Uploader)) {
	fake.setUploaderMutex.Lock()
	defer fake.setUploaderMutex.Unlock()
	fake.SetUploaderStub = stub
}

func (fake *FakeMarketplaceInterface) SetUploaderArgsForCall(i int) internal.Uploader {
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	argsForCall := fake.setUploaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) UploadVM(arg1 string, arg2 *models.Product, arg3 *models.Version) (*models.Product, error) {
	fake.uploadVMMutex.Lock()
	ret, specificReturn := fake.uploadVMReturnsOnCall[len(fake.uploadVMArgsForCall)]
	fake.uploadVMArgsForCall = append(fake.uploadVMArgsForCall, struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}{arg1, arg2, arg3})
	stub := fake.UploadVMStub
	fakeReturns := fake.uploadVMReturns
	fake.recordInvocation("UploadVM", []interface{}{arg1, arg2, arg3})
	fake.uploadVMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) UploadVMCallCount() int {
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	return len(fake.uploadVMArgsForCall)
}

func (fake *FakeMarketplaceInterface) UploadVMCalls(stub func(string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = stub
}

func (fake *FakeMarketplaceInterface) UploadVMArgsForCall(i int) (string, *models.Product, *models.Version) {
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	argsForCall := fake.uploadVMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) UploadVMReturns(result1 *models.Product, result2 error) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = nil
	fake.uploadVMReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) UploadVMReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = nil
	if fake.uploadVMReturnsOnCall == nil {
		fake.uploadVMReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.uploadVMReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	fake.attachOtherFileMutex.RLock()
	defer fake.attachOtherFileMutex.RUnlock()
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	fake.getHostMutex.RLock()
	defer fake.getHostMutex.RUnlock()
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMarketplaceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pkg.MarketplaceInterface = new(FakeMarketplaceInterface)
