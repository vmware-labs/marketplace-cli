// Code generated by counterfeiter. DO NOT EDIT.
package pkgfakes

import (
	"io"
	"net/http"
	"net/url"
	"sync"

	"github.com/vmware-labs/marketplace-cli/v2/internal"
	"github.com/vmware-labs/marketplace-cli/v2/internal/models"
	"github.com/vmware-labs/marketplace-cli/v2/pkg"
)

type FakeMarketplaceInterface struct {
	AttachLocalChartStub        func(string, string, *models.Product, *models.Version) (*models.Product, error)
	attachLocalChartMutex       sync.RWMutex
	attachLocalChartArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}
	attachLocalChartReturns struct {
		result1 *models.Product
		result2 error
	}
	attachLocalChartReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachLocalContainerImageStub        func(string, string, string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachLocalContainerImageMutex       sync.RWMutex
	attachLocalContainerImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *models.Product
		arg7 *models.Version
	}
	attachLocalContainerImageReturns struct {
		result1 *models.Product
		result2 error
	}
	attachLocalContainerImageReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachMetaFileStub        func(string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachMetaFileMutex       sync.RWMutex
	attachMetaFileArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *models.Product
		arg5 *models.Version
	}
	attachMetaFileReturns struct {
		result1 *models.Product
		result2 error
	}
	attachMetaFileReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachPublicChartStub        func(*url.URL, string, *models.Product, *models.Version) (*models.Product, error)
	attachPublicChartMutex       sync.RWMutex
	attachPublicChartArgsForCall []struct {
		arg1 *url.URL
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}
	attachPublicChartReturns struct {
		result1 *models.Product
		result2 error
	}
	attachPublicChartReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	AttachPublicContainerImageStub        func(string, string, string, string, *models.Product, *models.Version) (*models.Product, error)
	attachPublicContainerImageMutex       sync.RWMutex
	attachPublicContainerImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.Product
		arg6 *models.Version
	}
	attachPublicContainerImageReturns struct {
		result1 *models.Product
		result2 error
	}
	attachPublicContainerImageReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	DecodeJsonStub        func(io.Reader, interface{}) error
	decodeJsonMutex       sync.RWMutex
	decodeJsonArgsForCall []struct {
		arg1 io.Reader
		arg2 interface{}
	}
	decodeJsonReturns struct {
		result1 error
	}
	decodeJsonReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadStub        func(string, *pkg.DownloadRequestPayload) error
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		arg1 string
		arg2 *pkg.DownloadRequestPayload
	}
	downloadReturns struct {
		result1 error
	}
	downloadReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadChartStub        func(*url.URL) (*models.ChartVersion, error)
	downloadChartMutex       sync.RWMutex
	downloadChartArgsForCall []struct {
		arg1 *url.URL
	}
	downloadChartReturns struct {
		result1 *models.ChartVersion
		result2 error
	}
	downloadChartReturnsOnCall map[int]struct {
		result1 *models.ChartVersion
		result2 error
	}
	EnableDebuggingStub        func(bool, io.Writer)
	enableDebuggingMutex       sync.RWMutex
	enableDebuggingArgsForCall []struct {
		arg1 bool
		arg2 io.Writer
	}
	EnableStrictDecodingStub        func()
	enableStrictDecodingMutex       sync.RWMutex
	enableStrictDecodingArgsForCall []struct {
	}
	GetStub        func(*url.URL) (*http.Response, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 *url.URL
	}
	getReturns struct {
		result1 *http.Response
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	GetAPIHostStub        func() string
	getAPIHostMutex       sync.RWMutex
	getAPIHostArgsForCall []struct {
	}
	getAPIHostReturns struct {
		result1 string
	}
	getAPIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetProductStub        func(string) (*models.Product, error)
	getProductMutex       sync.RWMutex
	getProductArgsForCall []struct {
		arg1 string
	}
	getProductReturns struct {
		result1 *models.Product
		result2 error
	}
	getProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	GetProductWithVersionStub        func(string, string) (*models.Product, *models.Version, error)
	getProductWithVersionMutex       sync.RWMutex
	getProductWithVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getProductWithVersionReturns struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	getProductWithVersionReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	GetUIHostStub        func() string
	getUIHostMutex       sync.RWMutex
	getUIHostArgsForCall []struct {
	}
	getUIHostReturns struct {
		result1 string
	}
	getUIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetUploaderStub        func(string) (internal.Uploader, error)
	getUploaderMutex       sync.RWMutex
	getUploaderArgsForCall []struct {
		arg1 string
	}
	getUploaderReturns struct {
		result1 internal.Uploader
		result2 error
	}
	getUploaderReturnsOnCall map[int]struct {
		result1 internal.Uploader
		result2 error
	}
	ListProductsStub        func(bool, string) ([]*models.Product, error)
	listProductsMutex       sync.RWMutex
	listProductsArgsForCall []struct {
		arg1 bool
		arg2 string
	}
	listProductsReturns struct {
		result1 []*models.Product
		result2 error
	}
	listProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	MakeURLStub        func(string, url.Values) *url.URL
	makeURLMutex       sync.RWMutex
	makeURLArgsForCall []struct {
		arg1 string
		arg2 url.Values
	}
	makeURLReturns struct {
		result1 *url.URL
	}
	makeURLReturnsOnCall map[int]struct {
		result1 *url.URL
	}
	PostStub        func(*url.URL, io.Reader, string) (*http.Response, error)
	postMutex       sync.RWMutex
	postArgsForCall []struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}
	postReturns struct {
		result1 *http.Response
		result2 error
	}
	postReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutStub        func(*url.URL, io.Reader, string) (*http.Response, error)
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}
	putReturns struct {
		result1 *http.Response
		result2 error
	}
	putReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutProductStub        func(*models.Product, bool) (*models.Product, error)
	putProductMutex       sync.RWMutex
	putProductArgsForCall []struct {
		arg1 *models.Product
		arg2 bool
	}
	putProductReturns struct {
		result1 *models.Product
		result2 error
	}
	putProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	SendRequestStub        func(string, *url.URL, map[string]string, io.Reader) (*http.Response, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 string
		arg2 *url.URL
		arg3 map[string]string
		arg4 io.Reader
	}
	sendRequestReturns struct {
		result1 *http.Response
		result2 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	SetUploaderStub        func(internal.Uploader)
	setUploaderMutex       sync.RWMutex
	setUploaderArgsForCall []struct {
		arg1 internal.Uploader
	}
	UploadVMStub        func(string, *models.Product, *models.Version) (*models.Product, error)
	uploadVMMutex       sync.RWMutex
	uploadVMArgsForCall []struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}
	uploadVMReturns struct {
		result1 *models.Product
		result2 error
	}
	uploadVMReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMarketplaceInterface) AttachLocalChart(arg1 string, arg2 string, arg3 *models.Product, arg4 *models.Version) (*models.Product, error) {
	fake.attachLocalChartMutex.Lock()
	ret, specificReturn := fake.attachLocalChartReturnsOnCall[len(fake.attachLocalChartArgsForCall)]
	fake.attachLocalChartArgsForCall = append(fake.attachLocalChartArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}{arg1, arg2, arg3, arg4})
	stub := fake.AttachLocalChartStub
	fakeReturns := fake.attachLocalChartReturns
	fake.recordInvocation("AttachLocalChart", []interface{}{arg1, arg2, arg3, arg4})
	fake.attachLocalChartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachLocalChartCallCount() int {
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	return len(fake.attachLocalChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachLocalChartCalls(stub func(string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = stub
}

func (fake *FakeMarketplaceInterface) AttachLocalChartArgsForCall(i int) (string, string, *models.Product, *models.Version) {
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	argsForCall := fake.attachLocalChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) AttachLocalChartReturns(result1 *models.Product, result2 error) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = nil
	fake.attachLocalChartReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalChartReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachLocalChartMutex.Lock()
	defer fake.attachLocalChartMutex.Unlock()
	fake.AttachLocalChartStub = nil
	if fake.attachLocalChartReturnsOnCall == nil {
		fake.attachLocalChartReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachLocalChartReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImage(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string, arg6 *models.Product, arg7 *models.Version) (*models.Product, error) {
	fake.attachLocalContainerImageMutex.Lock()
	ret, specificReturn := fake.attachLocalContainerImageReturnsOnCall[len(fake.attachLocalContainerImageArgsForCall)]
	fake.attachLocalContainerImageArgsForCall = append(fake.attachLocalContainerImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 *models.Product
		arg7 *models.Version
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.AttachLocalContainerImageStub
	fakeReturns := fake.attachLocalContainerImageReturns
	fake.recordInvocation("AttachLocalContainerImage", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.attachLocalContainerImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageCallCount() int {
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	return len(fake.attachLocalContainerImageArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageCalls(stub func(string, string, string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = stub
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageArgsForCall(i int) (string, string, string, string, string, *models.Product, *models.Version) {
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	argsForCall := fake.attachLocalContainerImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageReturns(result1 *models.Product, result2 error) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = nil
	fake.attachLocalContainerImageReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachLocalContainerImageReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachLocalContainerImageMutex.Lock()
	defer fake.attachLocalContainerImageMutex.Unlock()
	fake.AttachLocalContainerImageStub = nil
	if fake.attachLocalContainerImageReturnsOnCall == nil {
		fake.attachLocalContainerImageReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachLocalContainerImageReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachMetaFile(arg1 string, arg2 string, arg3 string, arg4 *models.Product, arg5 *models.Version) (*models.Product, error) {
	fake.attachMetaFileMutex.Lock()
	ret, specificReturn := fake.attachMetaFileReturnsOnCall[len(fake.attachMetaFileArgsForCall)]
	fake.attachMetaFileArgsForCall = append(fake.attachMetaFileArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *models.Product
		arg5 *models.Version
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AttachMetaFileStub
	fakeReturns := fake.attachMetaFileReturns
	fake.recordInvocation("AttachMetaFile", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.attachMetaFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachMetaFileCallCount() int {
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	return len(fake.attachMetaFileArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachMetaFileCalls(stub func(string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = stub
}

func (fake *FakeMarketplaceInterface) AttachMetaFileArgsForCall(i int) (string, string, string, *models.Product, *models.Version) {
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	argsForCall := fake.attachMetaFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeMarketplaceInterface) AttachMetaFileReturns(result1 *models.Product, result2 error) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = nil
	fake.attachMetaFileReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachMetaFileReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachMetaFileMutex.Lock()
	defer fake.attachMetaFileMutex.Unlock()
	fake.AttachMetaFileStub = nil
	if fake.attachMetaFileReturnsOnCall == nil {
		fake.attachMetaFileReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachMetaFileReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicChart(arg1 *url.URL, arg2 string, arg3 *models.Product, arg4 *models.Version) (*models.Product, error) {
	fake.attachPublicChartMutex.Lock()
	ret, specificReturn := fake.attachPublicChartReturnsOnCall[len(fake.attachPublicChartArgsForCall)]
	fake.attachPublicChartArgsForCall = append(fake.attachPublicChartArgsForCall, struct {
		arg1 *url.URL
		arg2 string
		arg3 *models.Product
		arg4 *models.Version
	}{arg1, arg2, arg3, arg4})
	stub := fake.AttachPublicChartStub
	fakeReturns := fake.attachPublicChartReturns
	fake.recordInvocation("AttachPublicChart", []interface{}{arg1, arg2, arg3, arg4})
	fake.attachPublicChartMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachPublicChartCallCount() int {
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	return len(fake.attachPublicChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachPublicChartCalls(stub func(*url.URL, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = stub
}

func (fake *FakeMarketplaceInterface) AttachPublicChartArgsForCall(i int) (*url.URL, string, *models.Product, *models.Version) {
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	argsForCall := fake.attachPublicChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) AttachPublicChartReturns(result1 *models.Product, result2 error) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = nil
	fake.attachPublicChartReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicChartReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachPublicChartMutex.Lock()
	defer fake.attachPublicChartMutex.Unlock()
	fake.AttachPublicChartStub = nil
	if fake.attachPublicChartReturnsOnCall == nil {
		fake.attachPublicChartReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachPublicChartReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImage(arg1 string, arg2 string, arg3 string, arg4 string, arg5 *models.Product, arg6 *models.Version) (*models.Product, error) {
	fake.attachPublicContainerImageMutex.Lock()
	ret, specificReturn := fake.attachPublicContainerImageReturnsOnCall[len(fake.attachPublicContainerImageArgsForCall)]
	fake.attachPublicContainerImageArgsForCall = append(fake.attachPublicContainerImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.Product
		arg6 *models.Version
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.AttachPublicContainerImageStub
	fakeReturns := fake.attachPublicContainerImageReturns
	fake.recordInvocation("AttachPublicContainerImage", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.attachPublicContainerImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageCallCount() int {
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	return len(fake.attachPublicContainerImageArgsForCall)
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageCalls(stub func(string, string, string, string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = stub
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageArgsForCall(i int) (string, string, string, string, *models.Product, *models.Version) {
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	argsForCall := fake.attachPublicContainerImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageReturns(result1 *models.Product, result2 error) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = nil
	fake.attachPublicContainerImageReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) AttachPublicContainerImageReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.attachPublicContainerImageMutex.Lock()
	defer fake.attachPublicContainerImageMutex.Unlock()
	fake.AttachPublicContainerImageStub = nil
	if fake.attachPublicContainerImageReturnsOnCall == nil {
		fake.attachPublicContainerImageReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.attachPublicContainerImageReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) DecodeJson(arg1 io.Reader, arg2 interface{}) error {
	fake.decodeJsonMutex.Lock()
	ret, specificReturn := fake.decodeJsonReturnsOnCall[len(fake.decodeJsonArgsForCall)]
	fake.decodeJsonArgsForCall = append(fake.decodeJsonArgsForCall, struct {
		arg1 io.Reader
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.DecodeJsonStub
	fakeReturns := fake.decodeJsonReturns
	fake.recordInvocation("DecodeJson", []interface{}{arg1, arg2})
	fake.decodeJsonMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DecodeJsonCallCount() int {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	return len(fake.decodeJsonArgsForCall)
}

func (fake *FakeMarketplaceInterface) DecodeJsonCalls(stub func(io.Reader, interface{}) error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = stub
}

func (fake *FakeMarketplaceInterface) DecodeJsonArgsForCall(i int) (io.Reader, interface{}) {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	argsForCall := fake.decodeJsonArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturns(result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	fake.decodeJsonReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturnsOnCall(i int, result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	if fake.decodeJsonReturnsOnCall == nil {
		fake.decodeJsonReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decodeJsonReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) Download(arg1 string, arg2 *pkg.DownloadRequestPayload) error {
	fake.downloadMutex.Lock()
	ret, specificReturn := fake.downloadReturnsOnCall[len(fake.downloadArgsForCall)]
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		arg1 string
		arg2 *pkg.DownloadRequestPayload
	}{arg1, arg2})
	stub := fake.DownloadStub
	fakeReturns := fake.downloadReturns
	fake.recordInvocation("Download", []interface{}{arg1, arg2})
	fake.downloadMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadCalls(stub func(string, *pkg.DownloadRequestPayload) error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadArgsForCall(i int) (string, *pkg.DownloadRequestPayload) {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	argsForCall := fake.downloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) DownloadReturns(result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadReturnsOnCall(i int, result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	if fake.downloadReturnsOnCall == nil {
		fake.downloadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadChart(arg1 *url.URL) (*models.ChartVersion, error) {
	fake.downloadChartMutex.Lock()
	ret, specificReturn := fake.downloadChartReturnsOnCall[len(fake.downloadChartArgsForCall)]
	fake.downloadChartArgsForCall = append(fake.downloadChartArgsForCall, struct {
		arg1 *url.URL
	}{arg1})
	stub := fake.DownloadChartStub
	fakeReturns := fake.downloadChartReturns
	fake.recordInvocation("DownloadChart", []interface{}{arg1})
	fake.downloadChartMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) DownloadChartCallCount() int {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	return len(fake.downloadChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadChartCalls(stub func(*url.URL) (*models.ChartVersion, error)) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadChartArgsForCall(i int) *url.URL {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	argsForCall := fake.downloadChartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) DownloadChartReturns(result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	fake.downloadChartReturns = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) DownloadChartReturnsOnCall(i int, result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	if fake.downloadChartReturnsOnCall == nil {
		fake.downloadChartReturnsOnCall = make(map[int]struct {
			result1 *models.ChartVersion
			result2 error
		})
	}
	fake.downloadChartReturnsOnCall[i] = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) EnableDebugging(arg1 bool, arg2 io.Writer) {
	fake.enableDebuggingMutex.Lock()
	fake.enableDebuggingArgsForCall = append(fake.enableDebuggingArgsForCall, struct {
		arg1 bool
		arg2 io.Writer
	}{arg1, arg2})
	stub := fake.EnableDebuggingStub
	fake.recordInvocation("EnableDebugging", []interface{}{arg1, arg2})
	fake.enableDebuggingMutex.Unlock()
	if stub != nil {
		fake.EnableDebuggingStub(arg1, arg2)
	}
}

func (fake *FakeMarketplaceInterface) EnableDebuggingCallCount() int {
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	return len(fake.enableDebuggingArgsForCall)
}

func (fake *FakeMarketplaceInterface) EnableDebuggingCalls(stub func(bool, io.Writer)) {
	fake.enableDebuggingMutex.Lock()
	defer fake.enableDebuggingMutex.Unlock()
	fake.EnableDebuggingStub = stub
}

func (fake *FakeMarketplaceInterface) EnableDebuggingArgsForCall(i int) (bool, io.Writer) {
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	argsForCall := fake.enableDebuggingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) EnableStrictDecoding() {
	fake.enableStrictDecodingMutex.Lock()
	fake.enableStrictDecodingArgsForCall = append(fake.enableStrictDecodingArgsForCall, struct {
	}{})
	stub := fake.EnableStrictDecodingStub
	fake.recordInvocation("EnableStrictDecoding", []interface{}{})
	fake.enableStrictDecodingMutex.Unlock()
	if stub != nil {
		fake.EnableStrictDecodingStub()
	}
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCallCount() int {
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	return len(fake.enableStrictDecodingArgsForCall)
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCalls(stub func()) {
	fake.enableStrictDecodingMutex.Lock()
	defer fake.enableStrictDecodingMutex.Unlock()
	fake.EnableStrictDecodingStub = stub
}

func (fake *FakeMarketplaceInterface) Get(arg1 *url.URL) (*http.Response, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 *url.URL
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetCalls(stub func(*url.URL) (*http.Response, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeMarketplaceInterface) GetArgsForCall(i int) *url.URL {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetReturns(result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetAPIHost() string {
	fake.getAPIHostMutex.Lock()
	ret, specificReturn := fake.getAPIHostReturnsOnCall[len(fake.getAPIHostArgsForCall)]
	fake.getAPIHostArgsForCall = append(fake.getAPIHostArgsForCall, struct {
	}{})
	stub := fake.GetAPIHostStub
	fakeReturns := fake.getAPIHostReturns
	fake.recordInvocation("GetAPIHost", []interface{}{})
	fake.getAPIHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetAPIHostCallCount() int {
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	return len(fake.getAPIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetAPIHostCalls(stub func() string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturns(result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	fake.getAPIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturnsOnCall(i int, result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	if fake.getAPIHostReturnsOnCall == nil {
		fake.getAPIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getAPIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetProduct(arg1 string) (*models.Product, error) {
	fake.getProductMutex.Lock()
	ret, specificReturn := fake.getProductReturnsOnCall[len(fake.getProductArgsForCall)]
	fake.getProductArgsForCall = append(fake.getProductArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProductStub
	fakeReturns := fake.getProductReturns
	fake.recordInvocation("GetProduct", []interface{}{arg1})
	fake.getProductMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetProductCallCount() int {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	return len(fake.getProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductCalls(stub func(string) (*models.Product, error)) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductArgsForCall(i int) string {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	argsForCall := fake.getProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetProductReturns(result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	fake.getProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	if fake.getProductReturnsOnCall == nil {
		fake.getProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.getProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersion(arg1 string, arg2 string) (*models.Product, *models.Version, error) {
	fake.getProductWithVersionMutex.Lock()
	ret, specificReturn := fake.getProductWithVersionReturnsOnCall[len(fake.getProductWithVersionArgsForCall)]
	fake.getProductWithVersionArgsForCall = append(fake.getProductWithVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetProductWithVersionStub
	fakeReturns := fake.getProductWithVersionReturns
	fake.recordInvocation("GetProductWithVersion", []interface{}{arg1, arg2})
	fake.getProductWithVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCallCount() int {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	return len(fake.getProductWithVersionArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCalls(stub func(string, string) (*models.Product, *models.Version, error)) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionArgsForCall(i int) (string, string) {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	argsForCall := fake.getProductWithVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturns(result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	fake.getProductWithVersionReturns = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturnsOnCall(i int, result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	if fake.getProductWithVersionReturnsOnCall == nil {
		fake.getProductWithVersionReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 *models.Version
			result3 error
		})
	}
	fake.getProductWithVersionReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetUIHost() string {
	fake.getUIHostMutex.Lock()
	ret, specificReturn := fake.getUIHostReturnsOnCall[len(fake.getUIHostArgsForCall)]
	fake.getUIHostArgsForCall = append(fake.getUIHostArgsForCall, struct {
	}{})
	stub := fake.GetUIHostStub
	fakeReturns := fake.getUIHostReturns
	fake.recordInvocation("GetUIHost", []interface{}{})
	fake.getUIHostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetUIHostCallCount() int {
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	return len(fake.getUIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUIHostCalls(stub func() string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetUIHostReturns(result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	fake.getUIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUIHostReturnsOnCall(i int, result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	if fake.getUIHostReturnsOnCall == nil {
		fake.getUIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUploader(arg1 string) (internal.Uploader, error) {
	fake.getUploaderMutex.Lock()
	ret, specificReturn := fake.getUploaderReturnsOnCall[len(fake.getUploaderArgsForCall)]
	fake.getUploaderArgsForCall = append(fake.getUploaderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUploaderStub
	fakeReturns := fake.getUploaderReturns
	fake.recordInvocation("GetUploader", []interface{}{arg1})
	fake.getUploaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetUploaderCallCount() int {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	return len(fake.getUploaderArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUploaderCalls(stub func(string) (internal.Uploader, error)) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = stub
}

func (fake *FakeMarketplaceInterface) GetUploaderArgsForCall(i int) string {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	argsForCall := fake.getUploaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetUploaderReturns(result1 internal.Uploader, result2 error) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	fake.getUploaderReturns = struct {
		result1 internal.Uploader
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetUploaderReturnsOnCall(i int, result1 internal.Uploader, result2 error) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	if fake.getUploaderReturnsOnCall == nil {
		fake.getUploaderReturnsOnCall = make(map[int]struct {
			result1 internal.Uploader
			result2 error
		})
	}
	fake.getUploaderReturnsOnCall[i] = struct {
		result1 internal.Uploader
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) ListProducts(arg1 bool, arg2 string) ([]*models.Product, error) {
	fake.listProductsMutex.Lock()
	ret, specificReturn := fake.listProductsReturnsOnCall[len(fake.listProductsArgsForCall)]
	fake.listProductsArgsForCall = append(fake.listProductsArgsForCall, struct {
		arg1 bool
		arg2 string
	}{arg1, arg2})
	stub := fake.ListProductsStub
	fakeReturns := fake.listProductsReturns
	fake.recordInvocation("ListProducts", []interface{}{arg1, arg2})
	fake.listProductsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) ListProductsCallCount() int {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	return len(fake.listProductsArgsForCall)
}

func (fake *FakeMarketplaceInterface) ListProductsCalls(stub func(bool, string) ([]*models.Product, error)) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = stub
}

func (fake *FakeMarketplaceInterface) ListProductsArgsForCall(i int) (bool, string) {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	argsForCall := fake.listProductsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) ListProductsReturns(result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	fake.listProductsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) ListProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	if fake.listProductsReturnsOnCall == nil {
		fake.listProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.listProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) MakeURL(arg1 string, arg2 url.Values) *url.URL {
	fake.makeURLMutex.Lock()
	ret, specificReturn := fake.makeURLReturnsOnCall[len(fake.makeURLArgsForCall)]
	fake.makeURLArgsForCall = append(fake.makeURLArgsForCall, struct {
		arg1 string
		arg2 url.Values
	}{arg1, arg2})
	stub := fake.MakeURLStub
	fakeReturns := fake.makeURLReturns
	fake.recordInvocation("MakeURL", []interface{}{arg1, arg2})
	fake.makeURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) MakeURLCallCount() int {
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	return len(fake.makeURLArgsForCall)
}

func (fake *FakeMarketplaceInterface) MakeURLCalls(stub func(string, url.Values) *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = stub
}

func (fake *FakeMarketplaceInterface) MakeURLArgsForCall(i int) (string, url.Values) {
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	argsForCall := fake.makeURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) MakeURLReturns(result1 *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = nil
	fake.makeURLReturns = struct {
		result1 *url.URL
	}{result1}
}

func (fake *FakeMarketplaceInterface) MakeURLReturnsOnCall(i int, result1 *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = nil
	if fake.makeURLReturnsOnCall == nil {
		fake.makeURLReturnsOnCall = make(map[int]struct {
			result1 *url.URL
		})
	}
	fake.makeURLReturnsOnCall[i] = struct {
		result1 *url.URL
	}{result1}
}

func (fake *FakeMarketplaceInterface) Post(arg1 *url.URL, arg2 io.Reader, arg3 string) (*http.Response, error) {
	fake.postMutex.Lock()
	ret, specificReturn := fake.postReturnsOnCall[len(fake.postArgsForCall)]
	fake.postArgsForCall = append(fake.postArgsForCall, struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.PostStub
	fakeReturns := fake.postReturns
	fake.recordInvocation("Post", []interface{}{arg1, arg2, arg3})
	fake.postMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PostCallCount() int {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	return len(fake.postArgsForCall)
}

func (fake *FakeMarketplaceInterface) PostCalls(stub func(*url.URL, io.Reader, string) (*http.Response, error)) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = stub
}

func (fake *FakeMarketplaceInterface) PostArgsForCall(i int) (*url.URL, io.Reader, string) {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	argsForCall := fake.postArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) PostReturns(result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	fake.postReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PostReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	if fake.postReturnsOnCall == nil {
		fake.postReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.postReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) Put(arg1 *url.URL, arg2 io.Reader, arg3 string) (*http.Response, error) {
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.PutStub
	fakeReturns := fake.putReturns
	fake.recordInvocation("Put", []interface{}{arg1, arg2, arg3})
	fake.putMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeMarketplaceInterface) PutCalls(stub func(*url.URL, io.Reader, string) (*http.Response, error)) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *FakeMarketplaceInterface) PutArgsForCall(i int) (*url.URL, io.Reader, string) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) PutReturns(result1 *http.Response, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProduct(arg1 *models.Product, arg2 bool) (*models.Product, error) {
	fake.putProductMutex.Lock()
	ret, specificReturn := fake.putProductReturnsOnCall[len(fake.putProductArgsForCall)]
	fake.putProductArgsForCall = append(fake.putProductArgsForCall, struct {
		arg1 *models.Product
		arg2 bool
	}{arg1, arg2})
	stub := fake.PutProductStub
	fakeReturns := fake.putProductReturns
	fake.recordInvocation("PutProduct", []interface{}{arg1, arg2})
	fake.putProductMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PutProductCallCount() int {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	return len(fake.putProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) PutProductCalls(stub func(*models.Product, bool) (*models.Product, error)) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = stub
}

func (fake *FakeMarketplaceInterface) PutProductArgsForCall(i int) (*models.Product, bool) {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	argsForCall := fake.putProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) PutProductReturns(result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	fake.putProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	if fake.putProductReturnsOnCall == nil {
		fake.putProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.putProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SendRequest(arg1 string, arg2 *url.URL, arg3 map[string]string, arg4 io.Reader) (*http.Response, error) {
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 string
		arg2 *url.URL
		arg3 map[string]string
		arg4 io.Reader
	}{arg1, arg2, arg3, arg4})
	stub := fake.SendRequestStub
	fakeReturns := fake.sendRequestReturns
	fake.recordInvocation("SendRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.sendRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeMarketplaceInterface) SendRequestCalls(stub func(string, *url.URL, map[string]string, io.Reader) (*http.Response, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeMarketplaceInterface) SendRequestArgsForCall(i int) (string, *url.URL, map[string]string, io.Reader) {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) SendRequestReturns(result1 *http.Response, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SendRequestReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SetUploader(arg1 internal.Uploader) {
	fake.setUploaderMutex.Lock()
	fake.setUploaderArgsForCall = append(fake.setUploaderArgsForCall, struct {
		arg1 internal.Uploader
	}{arg1})
	stub := fake.SetUploaderStub
	fake.recordInvocation("SetUploader", []interface{}{arg1})
	fake.setUploaderMutex.Unlock()
	if stub != nil {
		fake.SetUploaderStub(arg1)
	}
}

func (fake *FakeMarketplaceInterface) SetUploaderCallCount() int {
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	return len(fake.setUploaderArgsForCall)
}

func (fake *FakeMarketplaceInterface) SetUploaderCalls(stub func(internal.Uploader)) {
	fake.setUploaderMutex.Lock()
	defer fake.setUploaderMutex.Unlock()
	fake.SetUploaderStub = stub
}

func (fake *FakeMarketplaceInterface) SetUploaderArgsForCall(i int) internal.Uploader {
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	argsForCall := fake.setUploaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) UploadVM(arg1 string, arg2 *models.Product, arg3 *models.Version) (*models.Product, error) {
	fake.uploadVMMutex.Lock()
	ret, specificReturn := fake.uploadVMReturnsOnCall[len(fake.uploadVMArgsForCall)]
	fake.uploadVMArgsForCall = append(fake.uploadVMArgsForCall, struct {
		arg1 string
		arg2 *models.Product
		arg3 *models.Version
	}{arg1, arg2, arg3})
	stub := fake.UploadVMStub
	fakeReturns := fake.uploadVMReturns
	fake.recordInvocation("UploadVM", []interface{}{arg1, arg2, arg3})
	fake.uploadVMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) UploadVMCallCount() int {
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	return len(fake.uploadVMArgsForCall)
}

func (fake *FakeMarketplaceInterface) UploadVMCalls(stub func(string, *models.Product, *models.Version) (*models.Product, error)) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = stub
}

func (fake *FakeMarketplaceInterface) UploadVMArgsForCall(i int) (string, *models.Product, *models.Version) {
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	argsForCall := fake.uploadVMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) UploadVMReturns(result1 *models.Product, result2 error) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = nil
	fake.uploadVMReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) UploadVMReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.uploadVMMutex.Lock()
	defer fake.uploadVMMutex.Unlock()
	fake.UploadVMStub = nil
	if fake.uploadVMReturnsOnCall == nil {
		fake.uploadVMReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.uploadVMReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachLocalChartMutex.RLock()
	defer fake.attachLocalChartMutex.RUnlock()
	fake.attachLocalContainerImageMutex.RLock()
	defer fake.attachLocalContainerImageMutex.RUnlock()
	fake.attachMetaFileMutex.RLock()
	defer fake.attachMetaFileMutex.RUnlock()
	fake.attachPublicChartMutex.RLock()
	defer fake.attachPublicChartMutex.RUnlock()
	fake.attachPublicContainerImageMutex.RLock()
	defer fake.attachPublicContainerImageMutex.RUnlock()
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	fake.setUploaderMutex.RLock()
	defer fake.setUploaderMutex.RUnlock()
	fake.uploadVMMutex.RLock()
	defer fake.uploadVMMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMarketplaceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pkg.MarketplaceInterface = new(FakeMarketplaceInterface)
