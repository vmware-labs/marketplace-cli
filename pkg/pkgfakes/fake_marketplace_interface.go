// Code generated by counterfeiter. DO NOT EDIT.
package pkgfakes

import (
	"io"
	"net/http"
	"net/url"
	"sync"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/vmware-labs/marketplace-cli/v2/internal"
	"github.com/vmware-labs/marketplace-cli/v2/internal/models"
	"github.com/vmware-labs/marketplace-cli/v2/pkg"
)

type FakeMarketplaceInterface struct {
	DecodeJsonStub        func(io.Reader, interface{}) error
	decodeJsonMutex       sync.RWMutex
	decodeJsonArgsForCall []struct {
		arg1 io.Reader
		arg2 interface{}
	}
	decodeJsonReturns struct {
		result1 error
	}
	decodeJsonReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadStub        func(string, string, *pkg.DownloadRequestPayload) error
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *pkg.DownloadRequestPayload
	}
	downloadReturns struct {
		result1 error
	}
	downloadReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadChartStub        func(*url.URL) (*models.ChartVersion, error)
	downloadChartMutex       sync.RWMutex
	downloadChartArgsForCall []struct {
		arg1 *url.URL
	}
	downloadChartReturns struct {
		result1 *models.ChartVersion
		result2 error
	}
	downloadChartReturnsOnCall map[int]struct {
		result1 *models.ChartVersion
		result2 error
	}
	EnableDebuggingStub        func(bool, io.Writer)
	enableDebuggingMutex       sync.RWMutex
	enableDebuggingArgsForCall []struct {
		arg1 bool
		arg2 io.Writer
	}
	EnableStrictDecodingStub        func()
	enableStrictDecodingMutex       sync.RWMutex
	enableStrictDecodingArgsForCall []struct {
	}
	GetStub        func(*url.URL) (*http.Response, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 *url.URL
	}
	getReturns struct {
		result1 *http.Response
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	GetAPIHostStub        func() string
	getAPIHostMutex       sync.RWMutex
	getAPIHostArgsForCall []struct {
	}
	getAPIHostReturns struct {
		result1 string
	}
	getAPIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetProductStub        func(string) (*models.Product, error)
	getProductMutex       sync.RWMutex
	getProductArgsForCall []struct {
		arg1 string
	}
	getProductReturns struct {
		result1 *models.Product
		result2 error
	}
	getProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	GetProductWithVersionStub        func(string, string) (*models.Product, *models.Version, error)
	getProductWithVersionMutex       sync.RWMutex
	getProductWithVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getProductWithVersionReturns struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	getProductWithVersionReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}
	GetUIHostStub        func() string
	getUIHostMutex       sync.RWMutex
	getUIHostArgsForCall []struct {
	}
	getUIHostReturns struct {
		result1 string
	}
	getUIHostReturnsOnCall map[int]struct {
		result1 string
	}
	GetUploadCredentialsStub        func() (*pkg.CredentialsResponse, error)
	getUploadCredentialsMutex       sync.RWMutex
	getUploadCredentialsArgsForCall []struct {
	}
	getUploadCredentialsReturns struct {
		result1 *pkg.CredentialsResponse
		result2 error
	}
	getUploadCredentialsReturnsOnCall map[int]struct {
		result1 *pkg.CredentialsResponse
		result2 error
	}
	GetUploaderStub        func(string, aws.Credentials) internal.Uploader
	getUploaderMutex       sync.RWMutex
	getUploaderArgsForCall []struct {
		arg1 string
		arg2 aws.Credentials
	}
	getUploaderReturns struct {
		result1 internal.Uploader
	}
	getUploaderReturnsOnCall map[int]struct {
		result1 internal.Uploader
	}
	ListProductsStub        func(bool, string) ([]*models.Product, error)
	listProductsMutex       sync.RWMutex
	listProductsArgsForCall []struct {
		arg1 bool
		arg2 string
	}
	listProductsReturns struct {
		result1 []*models.Product
		result2 error
	}
	listProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	MakeURLStub        func(string, url.Values) *url.URL
	makeURLMutex       sync.RWMutex
	makeURLArgsForCall []struct {
		arg1 string
		arg2 url.Values
	}
	makeURLReturns struct {
		result1 *url.URL
	}
	makeURLReturnsOnCall map[int]struct {
		result1 *url.URL
	}
	PostStub        func(*url.URL, io.Reader, string) (*http.Response, error)
	postMutex       sync.RWMutex
	postArgsForCall []struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}
	postReturns struct {
		result1 *http.Response
		result2 error
	}
	postReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutStub        func(*url.URL, io.Reader, string) (*http.Response, error)
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}
	putReturns struct {
		result1 *http.Response
		result2 error
	}
	putReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutProductStub        func(*models.Product, bool) (*models.Product, error)
	putProductMutex       sync.RWMutex
	putProductArgsForCall []struct {
		arg1 *models.Product
		arg2 bool
	}
	putProductReturns struct {
		result1 *models.Product
		result2 error
	}
	putProductReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	SendRequestStub        func(string, *url.URL, map[string]string, io.Reader) (*http.Response, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 string
		arg2 *url.URL
		arg3 map[string]string
		arg4 io.Reader
	}
	sendRequestReturns struct {
		result1 *http.Response
		result2 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMarketplaceInterface) DecodeJson(arg1 io.Reader, arg2 interface{}) error {
	fake.decodeJsonMutex.Lock()
	ret, specificReturn := fake.decodeJsonReturnsOnCall[len(fake.decodeJsonArgsForCall)]
	fake.decodeJsonArgsForCall = append(fake.decodeJsonArgsForCall, struct {
		arg1 io.Reader
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("DecodeJson", []interface{}{arg1, arg2})
	fake.decodeJsonMutex.Unlock()
	if fake.DecodeJsonStub != nil {
		return fake.DecodeJsonStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.decodeJsonReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DecodeJsonCallCount() int {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	return len(fake.decodeJsonArgsForCall)
}

func (fake *FakeMarketplaceInterface) DecodeJsonCalls(stub func(io.Reader, interface{}) error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = stub
}

func (fake *FakeMarketplaceInterface) DecodeJsonArgsForCall(i int) (io.Reader, interface{}) {
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	argsForCall := fake.decodeJsonArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturns(result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	fake.decodeJsonReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DecodeJsonReturnsOnCall(i int, result1 error) {
	fake.decodeJsonMutex.Lock()
	defer fake.decodeJsonMutex.Unlock()
	fake.DecodeJsonStub = nil
	if fake.decodeJsonReturnsOnCall == nil {
		fake.decodeJsonReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decodeJsonReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) Download(arg1 string, arg2 string, arg3 *pkg.DownloadRequestPayload) error {
	fake.downloadMutex.Lock()
	ret, specificReturn := fake.downloadReturnsOnCall[len(fake.downloadArgsForCall)]
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *pkg.DownloadRequestPayload
	}{arg1, arg2, arg3})
	fake.recordInvocation("Download", []interface{}{arg1, arg2, arg3})
	fake.downloadMutex.Unlock()
	if fake.DownloadStub != nil {
		return fake.DownloadStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.downloadReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadCalls(stub func(string, string, *pkg.DownloadRequestPayload) error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadArgsForCall(i int) (string, string, *pkg.DownloadRequestPayload) {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	argsForCall := fake.downloadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) DownloadReturns(result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadReturnsOnCall(i int, result1 error) {
	fake.downloadMutex.Lock()
	defer fake.downloadMutex.Unlock()
	fake.DownloadStub = nil
	if fake.downloadReturnsOnCall == nil {
		fake.downloadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMarketplaceInterface) DownloadChart(arg1 *url.URL) (*models.ChartVersion, error) {
	fake.downloadChartMutex.Lock()
	ret, specificReturn := fake.downloadChartReturnsOnCall[len(fake.downloadChartArgsForCall)]
	fake.downloadChartArgsForCall = append(fake.downloadChartArgsForCall, struct {
		arg1 *url.URL
	}{arg1})
	fake.recordInvocation("DownloadChart", []interface{}{arg1})
	fake.downloadChartMutex.Unlock()
	if fake.DownloadChartStub != nil {
		return fake.DownloadChartStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.downloadChartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) DownloadChartCallCount() int {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	return len(fake.downloadChartArgsForCall)
}

func (fake *FakeMarketplaceInterface) DownloadChartCalls(stub func(*url.URL) (*models.ChartVersion, error)) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = stub
}

func (fake *FakeMarketplaceInterface) DownloadChartArgsForCall(i int) *url.URL {
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	argsForCall := fake.downloadChartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) DownloadChartReturns(result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	fake.downloadChartReturns = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) DownloadChartReturnsOnCall(i int, result1 *models.ChartVersion, result2 error) {
	fake.downloadChartMutex.Lock()
	defer fake.downloadChartMutex.Unlock()
	fake.DownloadChartStub = nil
	if fake.downloadChartReturnsOnCall == nil {
		fake.downloadChartReturnsOnCall = make(map[int]struct {
			result1 *models.ChartVersion
			result2 error
		})
	}
	fake.downloadChartReturnsOnCall[i] = struct {
		result1 *models.ChartVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) EnableDebugging(arg1 bool, arg2 io.Writer) {
	fake.enableDebuggingMutex.Lock()
	fake.enableDebuggingArgsForCall = append(fake.enableDebuggingArgsForCall, struct {
		arg1 bool
		arg2 io.Writer
	}{arg1, arg2})
	fake.recordInvocation("EnableDebugging", []interface{}{arg1, arg2})
	fake.enableDebuggingMutex.Unlock()
	if fake.EnableDebuggingStub != nil {
		fake.EnableDebuggingStub(arg1, arg2)
	}
}

func (fake *FakeMarketplaceInterface) EnableDebuggingCallCount() int {
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	return len(fake.enableDebuggingArgsForCall)
}

func (fake *FakeMarketplaceInterface) EnableDebuggingCalls(stub func(bool, io.Writer)) {
	fake.enableDebuggingMutex.Lock()
	defer fake.enableDebuggingMutex.Unlock()
	fake.EnableDebuggingStub = stub
}

func (fake *FakeMarketplaceInterface) EnableDebuggingArgsForCall(i int) (bool, io.Writer) {
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	argsForCall := fake.enableDebuggingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) EnableStrictDecoding() {
	fake.enableStrictDecodingMutex.Lock()
	fake.enableStrictDecodingArgsForCall = append(fake.enableStrictDecodingArgsForCall, struct {
	}{})
	fake.recordInvocation("EnableStrictDecoding", []interface{}{})
	fake.enableStrictDecodingMutex.Unlock()
	if fake.EnableStrictDecodingStub != nil {
		fake.EnableStrictDecodingStub()
	}
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCallCount() int {
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	return len(fake.enableStrictDecodingArgsForCall)
}

func (fake *FakeMarketplaceInterface) EnableStrictDecodingCalls(stub func()) {
	fake.enableStrictDecodingMutex.Lock()
	defer fake.enableStrictDecodingMutex.Unlock()
	fake.EnableStrictDecodingStub = stub
}

func (fake *FakeMarketplaceInterface) Get(arg1 *url.URL) (*http.Response, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 *url.URL
	}{arg1})
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetCalls(stub func(*url.URL) (*http.Response, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeMarketplaceInterface) GetArgsForCall(i int) *url.URL {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetReturns(result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetAPIHost() string {
	fake.getAPIHostMutex.Lock()
	ret, specificReturn := fake.getAPIHostReturnsOnCall[len(fake.getAPIHostArgsForCall)]
	fake.getAPIHostArgsForCall = append(fake.getAPIHostArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAPIHost", []interface{}{})
	fake.getAPIHostMutex.Unlock()
	if fake.GetAPIHostStub != nil {
		return fake.GetAPIHostStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getAPIHostReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetAPIHostCallCount() int {
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	return len(fake.getAPIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetAPIHostCalls(stub func() string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturns(result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	fake.getAPIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetAPIHostReturnsOnCall(i int, result1 string) {
	fake.getAPIHostMutex.Lock()
	defer fake.getAPIHostMutex.Unlock()
	fake.GetAPIHostStub = nil
	if fake.getAPIHostReturnsOnCall == nil {
		fake.getAPIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getAPIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetProduct(arg1 string) (*models.Product, error) {
	fake.getProductMutex.Lock()
	ret, specificReturn := fake.getProductReturnsOnCall[len(fake.getProductArgsForCall)]
	fake.getProductArgsForCall = append(fake.getProductArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetProduct", []interface{}{arg1})
	fake.getProductMutex.Unlock()
	if fake.GetProductStub != nil {
		return fake.GetProductStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getProductReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetProductCallCount() int {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	return len(fake.getProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductCalls(stub func(string) (*models.Product, error)) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductArgsForCall(i int) string {
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	argsForCall := fake.getProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMarketplaceInterface) GetProductReturns(result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	fake.getProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.getProductMutex.Lock()
	defer fake.getProductMutex.Unlock()
	fake.GetProductStub = nil
	if fake.getProductReturnsOnCall == nil {
		fake.getProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.getProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersion(arg1 string, arg2 string) (*models.Product, *models.Version, error) {
	fake.getProductWithVersionMutex.Lock()
	ret, specificReturn := fake.getProductWithVersionReturnsOnCall[len(fake.getProductWithVersionArgsForCall)]
	fake.getProductWithVersionArgsForCall = append(fake.getProductWithVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetProductWithVersion", []interface{}{arg1, arg2})
	fake.getProductWithVersionMutex.Unlock()
	if fake.GetProductWithVersionStub != nil {
		return fake.GetProductWithVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getProductWithVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCallCount() int {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	return len(fake.getProductWithVersionArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionCalls(stub func(string, string) (*models.Product, *models.Version, error)) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = stub
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionArgsForCall(i int) (string, string) {
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	argsForCall := fake.getProductWithVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturns(result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	fake.getProductWithVersionReturns = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetProductWithVersionReturnsOnCall(i int, result1 *models.Product, result2 *models.Version, result3 error) {
	fake.getProductWithVersionMutex.Lock()
	defer fake.getProductWithVersionMutex.Unlock()
	fake.GetProductWithVersionStub = nil
	if fake.getProductWithVersionReturnsOnCall == nil {
		fake.getProductWithVersionReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 *models.Version
			result3 error
		})
	}
	fake.getProductWithVersionReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 *models.Version
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMarketplaceInterface) GetUIHost() string {
	fake.getUIHostMutex.Lock()
	ret, specificReturn := fake.getUIHostReturnsOnCall[len(fake.getUIHostArgsForCall)]
	fake.getUIHostArgsForCall = append(fake.getUIHostArgsForCall, struct {
	}{})
	fake.recordInvocation("GetUIHost", []interface{}{})
	fake.getUIHostMutex.Unlock()
	if fake.GetUIHostStub != nil {
		return fake.GetUIHostStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getUIHostReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetUIHostCallCount() int {
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	return len(fake.getUIHostArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUIHostCalls(stub func() string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = stub
}

func (fake *FakeMarketplaceInterface) GetUIHostReturns(result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	fake.getUIHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUIHostReturnsOnCall(i int, result1 string) {
	fake.getUIHostMutex.Lock()
	defer fake.getUIHostMutex.Unlock()
	fake.GetUIHostStub = nil
	if fake.getUIHostReturnsOnCall == nil {
		fake.getUIHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUIHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUploadCredentials() (*pkg.CredentialsResponse, error) {
	fake.getUploadCredentialsMutex.Lock()
	ret, specificReturn := fake.getUploadCredentialsReturnsOnCall[len(fake.getUploadCredentialsArgsForCall)]
	fake.getUploadCredentialsArgsForCall = append(fake.getUploadCredentialsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetUploadCredentials", []interface{}{})
	fake.getUploadCredentialsMutex.Unlock()
	if fake.GetUploadCredentialsStub != nil {
		return fake.GetUploadCredentialsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getUploadCredentialsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) GetUploadCredentialsCallCount() int {
	fake.getUploadCredentialsMutex.RLock()
	defer fake.getUploadCredentialsMutex.RUnlock()
	return len(fake.getUploadCredentialsArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUploadCredentialsCalls(stub func() (*pkg.CredentialsResponse, error)) {
	fake.getUploadCredentialsMutex.Lock()
	defer fake.getUploadCredentialsMutex.Unlock()
	fake.GetUploadCredentialsStub = stub
}

func (fake *FakeMarketplaceInterface) GetUploadCredentialsReturns(result1 *pkg.CredentialsResponse, result2 error) {
	fake.getUploadCredentialsMutex.Lock()
	defer fake.getUploadCredentialsMutex.Unlock()
	fake.GetUploadCredentialsStub = nil
	fake.getUploadCredentialsReturns = struct {
		result1 *pkg.CredentialsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetUploadCredentialsReturnsOnCall(i int, result1 *pkg.CredentialsResponse, result2 error) {
	fake.getUploadCredentialsMutex.Lock()
	defer fake.getUploadCredentialsMutex.Unlock()
	fake.GetUploadCredentialsStub = nil
	if fake.getUploadCredentialsReturnsOnCall == nil {
		fake.getUploadCredentialsReturnsOnCall = make(map[int]struct {
			result1 *pkg.CredentialsResponse
			result2 error
		})
	}
	fake.getUploadCredentialsReturnsOnCall[i] = struct {
		result1 *pkg.CredentialsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) GetUploader(arg1 string, arg2 aws.Credentials) internal.Uploader {
	fake.getUploaderMutex.Lock()
	ret, specificReturn := fake.getUploaderReturnsOnCall[len(fake.getUploaderArgsForCall)]
	fake.getUploaderArgsForCall = append(fake.getUploaderArgsForCall, struct {
		arg1 string
		arg2 aws.Credentials
	}{arg1, arg2})
	fake.recordInvocation("GetUploader", []interface{}{arg1, arg2})
	fake.getUploaderMutex.Unlock()
	if fake.GetUploaderStub != nil {
		return fake.GetUploaderStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getUploaderReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) GetUploaderCallCount() int {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	return len(fake.getUploaderArgsForCall)
}

func (fake *FakeMarketplaceInterface) GetUploaderCalls(stub func(string, aws.Credentials) internal.Uploader) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = stub
}

func (fake *FakeMarketplaceInterface) GetUploaderArgsForCall(i int) (string, aws.Credentials) {
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	argsForCall := fake.getUploaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) GetUploaderReturns(result1 internal.Uploader) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	fake.getUploaderReturns = struct {
		result1 internal.Uploader
	}{result1}
}

func (fake *FakeMarketplaceInterface) GetUploaderReturnsOnCall(i int, result1 internal.Uploader) {
	fake.getUploaderMutex.Lock()
	defer fake.getUploaderMutex.Unlock()
	fake.GetUploaderStub = nil
	if fake.getUploaderReturnsOnCall == nil {
		fake.getUploaderReturnsOnCall = make(map[int]struct {
			result1 internal.Uploader
		})
	}
	fake.getUploaderReturnsOnCall[i] = struct {
		result1 internal.Uploader
	}{result1}
}

func (fake *FakeMarketplaceInterface) ListProducts(arg1 bool, arg2 string) ([]*models.Product, error) {
	fake.listProductsMutex.Lock()
	ret, specificReturn := fake.listProductsReturnsOnCall[len(fake.listProductsArgsForCall)]
	fake.listProductsArgsForCall = append(fake.listProductsArgsForCall, struct {
		arg1 bool
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ListProducts", []interface{}{arg1, arg2})
	fake.listProductsMutex.Unlock()
	if fake.ListProductsStub != nil {
		return fake.ListProductsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listProductsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) ListProductsCallCount() int {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	return len(fake.listProductsArgsForCall)
}

func (fake *FakeMarketplaceInterface) ListProductsCalls(stub func(bool, string) ([]*models.Product, error)) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = stub
}

func (fake *FakeMarketplaceInterface) ListProductsArgsForCall(i int) (bool, string) {
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	argsForCall := fake.listProductsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) ListProductsReturns(result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	fake.listProductsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) ListProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.listProductsMutex.Lock()
	defer fake.listProductsMutex.Unlock()
	fake.ListProductsStub = nil
	if fake.listProductsReturnsOnCall == nil {
		fake.listProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.listProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) MakeURL(arg1 string, arg2 url.Values) *url.URL {
	fake.makeURLMutex.Lock()
	ret, specificReturn := fake.makeURLReturnsOnCall[len(fake.makeURLArgsForCall)]
	fake.makeURLArgsForCall = append(fake.makeURLArgsForCall, struct {
		arg1 string
		arg2 url.Values
	}{arg1, arg2})
	fake.recordInvocation("MakeURL", []interface{}{arg1, arg2})
	fake.makeURLMutex.Unlock()
	if fake.MakeURLStub != nil {
		return fake.MakeURLStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.makeURLReturns
	return fakeReturns.result1
}

func (fake *FakeMarketplaceInterface) MakeURLCallCount() int {
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	return len(fake.makeURLArgsForCall)
}

func (fake *FakeMarketplaceInterface) MakeURLCalls(stub func(string, url.Values) *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = stub
}

func (fake *FakeMarketplaceInterface) MakeURLArgsForCall(i int) (string, url.Values) {
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	argsForCall := fake.makeURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) MakeURLReturns(result1 *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = nil
	fake.makeURLReturns = struct {
		result1 *url.URL
	}{result1}
}

func (fake *FakeMarketplaceInterface) MakeURLReturnsOnCall(i int, result1 *url.URL) {
	fake.makeURLMutex.Lock()
	defer fake.makeURLMutex.Unlock()
	fake.MakeURLStub = nil
	if fake.makeURLReturnsOnCall == nil {
		fake.makeURLReturnsOnCall = make(map[int]struct {
			result1 *url.URL
		})
	}
	fake.makeURLReturnsOnCall[i] = struct {
		result1 *url.URL
	}{result1}
}

func (fake *FakeMarketplaceInterface) Post(arg1 *url.URL, arg2 io.Reader, arg3 string) (*http.Response, error) {
	fake.postMutex.Lock()
	ret, specificReturn := fake.postReturnsOnCall[len(fake.postArgsForCall)]
	fake.postArgsForCall = append(fake.postArgsForCall, struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("Post", []interface{}{arg1, arg2, arg3})
	fake.postMutex.Unlock()
	if fake.PostStub != nil {
		return fake.PostStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.postReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PostCallCount() int {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	return len(fake.postArgsForCall)
}

func (fake *FakeMarketplaceInterface) PostCalls(stub func(*url.URL, io.Reader, string) (*http.Response, error)) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = stub
}

func (fake *FakeMarketplaceInterface) PostArgsForCall(i int) (*url.URL, io.Reader, string) {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	argsForCall := fake.postArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) PostReturns(result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	fake.postReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PostReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	if fake.postReturnsOnCall == nil {
		fake.postReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.postReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) Put(arg1 *url.URL, arg2 io.Reader, arg3 string) (*http.Response, error) {
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 *url.URL
		arg2 io.Reader
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("Put", []interface{}{arg1, arg2, arg3})
	fake.putMutex.Unlock()
	if fake.PutStub != nil {
		return fake.PutStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.putReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeMarketplaceInterface) PutCalls(stub func(*url.URL, io.Reader, string) (*http.Response, error)) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *FakeMarketplaceInterface) PutArgsForCall(i int) (*url.URL, io.Reader, string) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMarketplaceInterface) PutReturns(result1 *http.Response, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProduct(arg1 *models.Product, arg2 bool) (*models.Product, error) {
	fake.putProductMutex.Lock()
	ret, specificReturn := fake.putProductReturnsOnCall[len(fake.putProductArgsForCall)]
	fake.putProductArgsForCall = append(fake.putProductArgsForCall, struct {
		arg1 *models.Product
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("PutProduct", []interface{}{arg1, arg2})
	fake.putProductMutex.Unlock()
	if fake.PutProductStub != nil {
		return fake.PutProductStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.putProductReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) PutProductCallCount() int {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	return len(fake.putProductArgsForCall)
}

func (fake *FakeMarketplaceInterface) PutProductCalls(stub func(*models.Product, bool) (*models.Product, error)) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = stub
}

func (fake *FakeMarketplaceInterface) PutProductArgsForCall(i int) (*models.Product, bool) {
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	argsForCall := fake.putProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMarketplaceInterface) PutProductReturns(result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	fake.putProductReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) PutProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.putProductMutex.Lock()
	defer fake.putProductMutex.Unlock()
	fake.PutProductStub = nil
	if fake.putProductReturnsOnCall == nil {
		fake.putProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.putProductReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SendRequest(arg1 string, arg2 *url.URL, arg3 map[string]string, arg4 io.Reader) (*http.Response, error) {
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 string
		arg2 *url.URL
		arg3 map[string]string
		arg4 io.Reader
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SendRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.sendRequestMutex.Unlock()
	if fake.SendRequestStub != nil {
		return fake.SendRequestStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.sendRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMarketplaceInterface) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeMarketplaceInterface) SendRequestCalls(stub func(string, *url.URL, map[string]string, io.Reader) (*http.Response, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeMarketplaceInterface) SendRequestArgsForCall(i int) (string, *url.URL, map[string]string, io.Reader) {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMarketplaceInterface) SendRequestReturns(result1 *http.Response, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) SendRequestReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeMarketplaceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.decodeJsonMutex.RLock()
	defer fake.decodeJsonMutex.RUnlock()
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	fake.downloadChartMutex.RLock()
	defer fake.downloadChartMutex.RUnlock()
	fake.enableDebuggingMutex.RLock()
	defer fake.enableDebuggingMutex.RUnlock()
	fake.enableStrictDecodingMutex.RLock()
	defer fake.enableStrictDecodingMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getAPIHostMutex.RLock()
	defer fake.getAPIHostMutex.RUnlock()
	fake.getProductMutex.RLock()
	defer fake.getProductMutex.RUnlock()
	fake.getProductWithVersionMutex.RLock()
	defer fake.getProductWithVersionMutex.RUnlock()
	fake.getUIHostMutex.RLock()
	defer fake.getUIHostMutex.RUnlock()
	fake.getUploadCredentialsMutex.RLock()
	defer fake.getUploadCredentialsMutex.RUnlock()
	fake.getUploaderMutex.RLock()
	defer fake.getUploaderMutex.RUnlock()
	fake.listProductsMutex.RLock()
	defer fake.listProductsMutex.RUnlock()
	fake.makeURLMutex.RLock()
	defer fake.makeURLMutex.RUnlock()
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.putProductMutex.RLock()
	defer fake.putProductMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMarketplaceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pkg.MarketplaceInterface = new(FakeMarketplaceInterface)
