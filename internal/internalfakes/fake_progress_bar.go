// Code generated by counterfeiter. DO NOT EDIT.
package internalfakes

import (
	"io"
	"sync"

	"github.com/vmware-labs/marketplace-cli/v2/internal"
)

type FakeProgressBar struct {
	WrapReaderStub        func(io.Reader) io.Reader
	wrapReaderMutex       sync.RWMutex
	wrapReaderArgsForCall []struct {
		arg1 io.Reader
	}
	wrapReaderReturns struct {
		result1 io.Reader
	}
	wrapReaderReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	WrapWriterStub        func(io.Writer) io.Writer
	wrapWriterMutex       sync.RWMutex
	wrapWriterArgsForCall []struct {
		arg1 io.Writer
	}
	wrapWriterReturns struct {
		result1 io.Writer
	}
	wrapWriterReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeProgressBar) WrapReader(arg1 io.Reader) io.Reader {
	fake.wrapReaderMutex.Lock()
	ret, specificReturn := fake.wrapReaderReturnsOnCall[len(fake.wrapReaderArgsForCall)]
	fake.wrapReaderArgsForCall = append(fake.wrapReaderArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	stub := fake.WrapReaderStub
	fakeReturns := fake.wrapReaderReturns
	fake.recordInvocation("WrapReader", []interface{}{arg1})
	fake.wrapReaderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeProgressBar) WrapReaderCallCount() int {
	fake.wrapReaderMutex.RLock()
	defer fake.wrapReaderMutex.RUnlock()
	return len(fake.wrapReaderArgsForCall)
}

func (fake *FakeProgressBar) WrapReaderCalls(stub func(io.Reader) io.Reader) {
	fake.wrapReaderMutex.Lock()
	defer fake.wrapReaderMutex.Unlock()
	fake.WrapReaderStub = stub
}

func (fake *FakeProgressBar) WrapReaderArgsForCall(i int) io.Reader {
	fake.wrapReaderMutex.RLock()
	defer fake.wrapReaderMutex.RUnlock()
	argsForCall := fake.wrapReaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProgressBar) WrapReaderReturns(result1 io.Reader) {
	fake.wrapReaderMutex.Lock()
	defer fake.wrapReaderMutex.Unlock()
	fake.WrapReaderStub = nil
	fake.wrapReaderReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeProgressBar) WrapReaderReturnsOnCall(i int, result1 io.Reader) {
	fake.wrapReaderMutex.Lock()
	defer fake.wrapReaderMutex.Unlock()
	fake.WrapReaderStub = nil
	if fake.wrapReaderReturnsOnCall == nil {
		fake.wrapReaderReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.wrapReaderReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeProgressBar) WrapWriter(arg1 io.Writer) io.Writer {
	fake.wrapWriterMutex.Lock()
	ret, specificReturn := fake.wrapWriterReturnsOnCall[len(fake.wrapWriterArgsForCall)]
	fake.wrapWriterArgsForCall = append(fake.wrapWriterArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	stub := fake.WrapWriterStub
	fakeReturns := fake.wrapWriterReturns
	fake.recordInvocation("WrapWriter", []interface{}{arg1})
	fake.wrapWriterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeProgressBar) WrapWriterCallCount() int {
	fake.wrapWriterMutex.RLock()
	defer fake.wrapWriterMutex.RUnlock()
	return len(fake.wrapWriterArgsForCall)
}

func (fake *FakeProgressBar) WrapWriterCalls(stub func(io.Writer) io.Writer) {
	fake.wrapWriterMutex.Lock()
	defer fake.wrapWriterMutex.Unlock()
	fake.WrapWriterStub = stub
}

func (fake *FakeProgressBar) WrapWriterArgsForCall(i int) io.Writer {
	fake.wrapWriterMutex.RLock()
	defer fake.wrapWriterMutex.RUnlock()
	argsForCall := fake.wrapWriterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeProgressBar) WrapWriterReturns(result1 io.Writer) {
	fake.wrapWriterMutex.Lock()
	defer fake.wrapWriterMutex.Unlock()
	fake.WrapWriterStub = nil
	fake.wrapWriterReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeProgressBar) WrapWriterReturnsOnCall(i int, result1 io.Writer) {
	fake.wrapWriterMutex.Lock()
	defer fake.wrapWriterMutex.Unlock()
	fake.WrapWriterStub = nil
	if fake.wrapWriterReturnsOnCall == nil {
		fake.wrapWriterReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.wrapWriterReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeProgressBar) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.wrapReaderMutex.RLock()
	defer fake.wrapReaderMutex.RUnlock()
	fake.wrapWriterMutex.RLock()
	defer fake.wrapWriterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeProgressBar) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ internal.ProgressBar = new(FakeProgressBar)
