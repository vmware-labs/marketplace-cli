// Code generated by counterfeiter. DO NOT EDIT.
package outputfakes

import (
	"sync"

	"github.com/vmware-labs/marketplace-cli/v2/cmd/output"
	"github.com/vmware-labs/marketplace-cli/v2/internal/models"
	"github.com/vmware-labs/marketplace-cli/v2/pkg"
)

type FakeFormat struct {
	PrintHeaderStub        func(string)
	printHeaderMutex       sync.RWMutex
	printHeaderArgsForCall []struct {
		arg1 string
	}
	RenderAssetsStub        func([]*pkg.Asset) error
	renderAssetsMutex       sync.RWMutex
	renderAssetsArgsForCall []struct {
		arg1 []*pkg.Asset
	}
	renderAssetsReturns struct {
		result1 error
	}
	renderAssetsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderChartStub        func(*models.ChartVersion) error
	renderChartMutex       sync.RWMutex
	renderChartArgsForCall []struct {
		arg1 *models.ChartVersion
	}
	renderChartReturns struct {
		result1 error
	}
	renderChartReturnsOnCall map[int]struct {
		result1 error
	}
	RenderChartsStub        func([]*models.ChartVersion) error
	renderChartsMutex       sync.RWMutex
	renderChartsArgsForCall []struct {
		arg1 []*models.ChartVersion
	}
	renderChartsReturns struct {
		result1 error
	}
	renderChartsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderContainerImageStub        func(*models.DockerURLDetails) error
	renderContainerImageMutex       sync.RWMutex
	renderContainerImageArgsForCall []struct {
		arg1 *models.DockerURLDetails
	}
	renderContainerImageReturns struct {
		result1 error
	}
	renderContainerImageReturnsOnCall map[int]struct {
		result1 error
	}
	RenderContainerImagesStub        func(*models.DockerVersionList) error
	renderContainerImagesMutex       sync.RWMutex
	renderContainerImagesArgsForCall []struct {
		arg1 *models.DockerVersionList
	}
	renderContainerImagesReturns struct {
		result1 error
	}
	renderContainerImagesReturnsOnCall map[int]struct {
		result1 error
	}
	RenderFileStub        func(*models.ProductDeploymentFile) error
	renderFileMutex       sync.RWMutex
	renderFileArgsForCall []struct {
		arg1 *models.ProductDeploymentFile
	}
	renderFileReturns struct {
		result1 error
	}
	renderFileReturnsOnCall map[int]struct {
		result1 error
	}
	RenderFilesStub        func([]*models.ProductDeploymentFile) error
	renderFilesMutex       sync.RWMutex
	renderFilesArgsForCall []struct {
		arg1 []*models.ProductDeploymentFile
	}
	renderFilesReturns struct {
		result1 error
	}
	renderFilesReturnsOnCall map[int]struct {
		result1 error
	}
	RenderProductStub        func(*models.Product, *models.Version) error
	renderProductMutex       sync.RWMutex
	renderProductArgsForCall []struct {
		arg1 *models.Product
		arg2 *models.Version
	}
	renderProductReturns struct {
		result1 error
	}
	renderProductReturnsOnCall map[int]struct {
		result1 error
	}
	RenderProductsStub        func([]*models.Product) error
	renderProductsMutex       sync.RWMutex
	renderProductsArgsForCall []struct {
		arg1 []*models.Product
	}
	renderProductsReturns struct {
		result1 error
	}
	renderProductsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderVersionsStub        func(*models.Product) error
	renderVersionsMutex       sync.RWMutex
	renderVersionsArgsForCall []struct {
		arg1 *models.Product
	}
	renderVersionsReturns struct {
		result1 error
	}
	renderVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFormat) PrintHeader(arg1 string) {
	fake.printHeaderMutex.Lock()
	fake.printHeaderArgsForCall = append(fake.printHeaderArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("PrintHeader", []interface{}{arg1})
	fake.printHeaderMutex.Unlock()
	if fake.PrintHeaderStub != nil {
		fake.PrintHeaderStub(arg1)
	}
}

func (fake *FakeFormat) PrintHeaderCallCount() int {
	fake.printHeaderMutex.RLock()
	defer fake.printHeaderMutex.RUnlock()
	return len(fake.printHeaderArgsForCall)
}

func (fake *FakeFormat) PrintHeaderCalls(stub func(string)) {
	fake.printHeaderMutex.Lock()
	defer fake.printHeaderMutex.Unlock()
	fake.PrintHeaderStub = stub
}

func (fake *FakeFormat) PrintHeaderArgsForCall(i int) string {
	fake.printHeaderMutex.RLock()
	defer fake.printHeaderMutex.RUnlock()
	argsForCall := fake.printHeaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderAssets(arg1 []*pkg.Asset) error {
	var arg1Copy []*pkg.Asset
	if arg1 != nil {
		arg1Copy = make([]*pkg.Asset, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderAssetsMutex.Lock()
	ret, specificReturn := fake.renderAssetsReturnsOnCall[len(fake.renderAssetsArgsForCall)]
	fake.renderAssetsArgsForCall = append(fake.renderAssetsArgsForCall, struct {
		arg1 []*pkg.Asset
	}{arg1Copy})
	fake.recordInvocation("RenderAssets", []interface{}{arg1Copy})
	fake.renderAssetsMutex.Unlock()
	if fake.RenderAssetsStub != nil {
		return fake.RenderAssetsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderAssetsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderAssetsCallCount() int {
	fake.renderAssetsMutex.RLock()
	defer fake.renderAssetsMutex.RUnlock()
	return len(fake.renderAssetsArgsForCall)
}

func (fake *FakeFormat) RenderAssetsCalls(stub func([]*pkg.Asset) error) {
	fake.renderAssetsMutex.Lock()
	defer fake.renderAssetsMutex.Unlock()
	fake.RenderAssetsStub = stub
}

func (fake *FakeFormat) RenderAssetsArgsForCall(i int) []*pkg.Asset {
	fake.renderAssetsMutex.RLock()
	defer fake.renderAssetsMutex.RUnlock()
	argsForCall := fake.renderAssetsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderAssetsReturns(result1 error) {
	fake.renderAssetsMutex.Lock()
	defer fake.renderAssetsMutex.Unlock()
	fake.RenderAssetsStub = nil
	fake.renderAssetsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderAssetsReturnsOnCall(i int, result1 error) {
	fake.renderAssetsMutex.Lock()
	defer fake.renderAssetsMutex.Unlock()
	fake.RenderAssetsStub = nil
	if fake.renderAssetsReturnsOnCall == nil {
		fake.renderAssetsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderAssetsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderChart(arg1 *models.ChartVersion) error {
	fake.renderChartMutex.Lock()
	ret, specificReturn := fake.renderChartReturnsOnCall[len(fake.renderChartArgsForCall)]
	fake.renderChartArgsForCall = append(fake.renderChartArgsForCall, struct {
		arg1 *models.ChartVersion
	}{arg1})
	fake.recordInvocation("RenderChart", []interface{}{arg1})
	fake.renderChartMutex.Unlock()
	if fake.RenderChartStub != nil {
		return fake.RenderChartStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderChartReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderChartCallCount() int {
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	return len(fake.renderChartArgsForCall)
}

func (fake *FakeFormat) RenderChartCalls(stub func(*models.ChartVersion) error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = stub
}

func (fake *FakeFormat) RenderChartArgsForCall(i int) *models.ChartVersion {
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	argsForCall := fake.renderChartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderChartReturns(result1 error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = nil
	fake.renderChartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderChartReturnsOnCall(i int, result1 error) {
	fake.renderChartMutex.Lock()
	defer fake.renderChartMutex.Unlock()
	fake.RenderChartStub = nil
	if fake.renderChartReturnsOnCall == nil {
		fake.renderChartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderChartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderCharts(arg1 []*models.ChartVersion) error {
	var arg1Copy []*models.ChartVersion
	if arg1 != nil {
		arg1Copy = make([]*models.ChartVersion, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderChartsMutex.Lock()
	ret, specificReturn := fake.renderChartsReturnsOnCall[len(fake.renderChartsArgsForCall)]
	fake.renderChartsArgsForCall = append(fake.renderChartsArgsForCall, struct {
		arg1 []*models.ChartVersion
	}{arg1Copy})
	fake.recordInvocation("RenderCharts", []interface{}{arg1Copy})
	fake.renderChartsMutex.Unlock()
	if fake.RenderChartsStub != nil {
		return fake.RenderChartsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderChartsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderChartsCallCount() int {
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	return len(fake.renderChartsArgsForCall)
}

func (fake *FakeFormat) RenderChartsCalls(stub func([]*models.ChartVersion) error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = stub
}

func (fake *FakeFormat) RenderChartsArgsForCall(i int) []*models.ChartVersion {
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	argsForCall := fake.renderChartsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderChartsReturns(result1 error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = nil
	fake.renderChartsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderChartsReturnsOnCall(i int, result1 error) {
	fake.renderChartsMutex.Lock()
	defer fake.renderChartsMutex.Unlock()
	fake.RenderChartsStub = nil
	if fake.renderChartsReturnsOnCall == nil {
		fake.renderChartsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderChartsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImage(arg1 *models.DockerURLDetails) error {
	fake.renderContainerImageMutex.Lock()
	ret, specificReturn := fake.renderContainerImageReturnsOnCall[len(fake.renderContainerImageArgsForCall)]
	fake.renderContainerImageArgsForCall = append(fake.renderContainerImageArgsForCall, struct {
		arg1 *models.DockerURLDetails
	}{arg1})
	fake.recordInvocation("RenderContainerImage", []interface{}{arg1})
	fake.renderContainerImageMutex.Unlock()
	if fake.RenderContainerImageStub != nil {
		return fake.RenderContainerImageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderContainerImageReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderContainerImageCallCount() int {
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	return len(fake.renderContainerImageArgsForCall)
}

func (fake *FakeFormat) RenderContainerImageCalls(stub func(*models.DockerURLDetails) error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = stub
}

func (fake *FakeFormat) RenderContainerImageArgsForCall(i int) *models.DockerURLDetails {
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	argsForCall := fake.renderContainerImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderContainerImageReturns(result1 error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = nil
	fake.renderContainerImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImageReturnsOnCall(i int, result1 error) {
	fake.renderContainerImageMutex.Lock()
	defer fake.renderContainerImageMutex.Unlock()
	fake.RenderContainerImageStub = nil
	if fake.renderContainerImageReturnsOnCall == nil {
		fake.renderContainerImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderContainerImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImages(arg1 *models.DockerVersionList) error {
	fake.renderContainerImagesMutex.Lock()
	ret, specificReturn := fake.renderContainerImagesReturnsOnCall[len(fake.renderContainerImagesArgsForCall)]
	fake.renderContainerImagesArgsForCall = append(fake.renderContainerImagesArgsForCall, struct {
		arg1 *models.DockerVersionList
	}{arg1})
	fake.recordInvocation("RenderContainerImages", []interface{}{arg1})
	fake.renderContainerImagesMutex.Unlock()
	if fake.RenderContainerImagesStub != nil {
		return fake.RenderContainerImagesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderContainerImagesReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderContainerImagesCallCount() int {
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	return len(fake.renderContainerImagesArgsForCall)
}

func (fake *FakeFormat) RenderContainerImagesCalls(stub func(*models.DockerVersionList) error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = stub
}

func (fake *FakeFormat) RenderContainerImagesArgsForCall(i int) *models.DockerVersionList {
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	argsForCall := fake.renderContainerImagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderContainerImagesReturns(result1 error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = nil
	fake.renderContainerImagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderContainerImagesReturnsOnCall(i int, result1 error) {
	fake.renderContainerImagesMutex.Lock()
	defer fake.renderContainerImagesMutex.Unlock()
	fake.RenderContainerImagesStub = nil
	if fake.renderContainerImagesReturnsOnCall == nil {
		fake.renderContainerImagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderContainerImagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderFile(arg1 *models.ProductDeploymentFile) error {
	fake.renderFileMutex.Lock()
	ret, specificReturn := fake.renderFileReturnsOnCall[len(fake.renderFileArgsForCall)]
	fake.renderFileArgsForCall = append(fake.renderFileArgsForCall, struct {
		arg1 *models.ProductDeploymentFile
	}{arg1})
	fake.recordInvocation("RenderFile", []interface{}{arg1})
	fake.renderFileMutex.Unlock()
	if fake.RenderFileStub != nil {
		return fake.RenderFileStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderFileReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderFileCallCount() int {
	fake.renderFileMutex.RLock()
	defer fake.renderFileMutex.RUnlock()
	return len(fake.renderFileArgsForCall)
}

func (fake *FakeFormat) RenderFileCalls(stub func(*models.ProductDeploymentFile) error) {
	fake.renderFileMutex.Lock()
	defer fake.renderFileMutex.Unlock()
	fake.RenderFileStub = stub
}

func (fake *FakeFormat) RenderFileArgsForCall(i int) *models.ProductDeploymentFile {
	fake.renderFileMutex.RLock()
	defer fake.renderFileMutex.RUnlock()
	argsForCall := fake.renderFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderFileReturns(result1 error) {
	fake.renderFileMutex.Lock()
	defer fake.renderFileMutex.Unlock()
	fake.RenderFileStub = nil
	fake.renderFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderFileReturnsOnCall(i int, result1 error) {
	fake.renderFileMutex.Lock()
	defer fake.renderFileMutex.Unlock()
	fake.RenderFileStub = nil
	if fake.renderFileReturnsOnCall == nil {
		fake.renderFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderFiles(arg1 []*models.ProductDeploymentFile) error {
	var arg1Copy []*models.ProductDeploymentFile
	if arg1 != nil {
		arg1Copy = make([]*models.ProductDeploymentFile, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderFilesMutex.Lock()
	ret, specificReturn := fake.renderFilesReturnsOnCall[len(fake.renderFilesArgsForCall)]
	fake.renderFilesArgsForCall = append(fake.renderFilesArgsForCall, struct {
		arg1 []*models.ProductDeploymentFile
	}{arg1Copy})
	fake.recordInvocation("RenderFiles", []interface{}{arg1Copy})
	fake.renderFilesMutex.Unlock()
	if fake.RenderFilesStub != nil {
		return fake.RenderFilesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderFilesReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderFilesCallCount() int {
	fake.renderFilesMutex.RLock()
	defer fake.renderFilesMutex.RUnlock()
	return len(fake.renderFilesArgsForCall)
}

func (fake *FakeFormat) RenderFilesCalls(stub func([]*models.ProductDeploymentFile) error) {
	fake.renderFilesMutex.Lock()
	defer fake.renderFilesMutex.Unlock()
	fake.RenderFilesStub = stub
}

func (fake *FakeFormat) RenderFilesArgsForCall(i int) []*models.ProductDeploymentFile {
	fake.renderFilesMutex.RLock()
	defer fake.renderFilesMutex.RUnlock()
	argsForCall := fake.renderFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderFilesReturns(result1 error) {
	fake.renderFilesMutex.Lock()
	defer fake.renderFilesMutex.Unlock()
	fake.RenderFilesStub = nil
	fake.renderFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderFilesReturnsOnCall(i int, result1 error) {
	fake.renderFilesMutex.Lock()
	defer fake.renderFilesMutex.Unlock()
	fake.RenderFilesStub = nil
	if fake.renderFilesReturnsOnCall == nil {
		fake.renderFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProduct(arg1 *models.Product, arg2 *models.Version) error {
	fake.renderProductMutex.Lock()
	ret, specificReturn := fake.renderProductReturnsOnCall[len(fake.renderProductArgsForCall)]
	fake.renderProductArgsForCall = append(fake.renderProductArgsForCall, struct {
		arg1 *models.Product
		arg2 *models.Version
	}{arg1, arg2})
	fake.recordInvocation("RenderProduct", []interface{}{arg1, arg2})
	fake.renderProductMutex.Unlock()
	if fake.RenderProductStub != nil {
		return fake.RenderProductStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderProductReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderProductCallCount() int {
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	return len(fake.renderProductArgsForCall)
}

func (fake *FakeFormat) RenderProductCalls(stub func(*models.Product, *models.Version) error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = stub
}

func (fake *FakeFormat) RenderProductArgsForCall(i int) (*models.Product, *models.Version) {
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	argsForCall := fake.renderProductArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFormat) RenderProductReturns(result1 error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = nil
	fake.renderProductReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProductReturnsOnCall(i int, result1 error) {
	fake.renderProductMutex.Lock()
	defer fake.renderProductMutex.Unlock()
	fake.RenderProductStub = nil
	if fake.renderProductReturnsOnCall == nil {
		fake.renderProductReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderProductReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProducts(arg1 []*models.Product) error {
	var arg1Copy []*models.Product
	if arg1 != nil {
		arg1Copy = make([]*models.Product, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderProductsMutex.Lock()
	ret, specificReturn := fake.renderProductsReturnsOnCall[len(fake.renderProductsArgsForCall)]
	fake.renderProductsArgsForCall = append(fake.renderProductsArgsForCall, struct {
		arg1 []*models.Product
	}{arg1Copy})
	fake.recordInvocation("RenderProducts", []interface{}{arg1Copy})
	fake.renderProductsMutex.Unlock()
	if fake.RenderProductsStub != nil {
		return fake.RenderProductsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderProductsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderProductsCallCount() int {
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	return len(fake.renderProductsArgsForCall)
}

func (fake *FakeFormat) RenderProductsCalls(stub func([]*models.Product) error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = stub
}

func (fake *FakeFormat) RenderProductsArgsForCall(i int) []*models.Product {
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	argsForCall := fake.renderProductsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderProductsReturns(result1 error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = nil
	fake.renderProductsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderProductsReturnsOnCall(i int, result1 error) {
	fake.renderProductsMutex.Lock()
	defer fake.renderProductsMutex.Unlock()
	fake.RenderProductsStub = nil
	if fake.renderProductsReturnsOnCall == nil {
		fake.renderProductsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderProductsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersions(arg1 *models.Product) error {
	fake.renderVersionsMutex.Lock()
	ret, specificReturn := fake.renderVersionsReturnsOnCall[len(fake.renderVersionsArgsForCall)]
	fake.renderVersionsArgsForCall = append(fake.renderVersionsArgsForCall, struct {
		arg1 *models.Product
	}{arg1})
	fake.recordInvocation("RenderVersions", []interface{}{arg1})
	fake.renderVersionsMutex.Unlock()
	if fake.RenderVersionsStub != nil {
		return fake.RenderVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renderVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeFormat) RenderVersionsCallCount() int {
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	return len(fake.renderVersionsArgsForCall)
}

func (fake *FakeFormat) RenderVersionsCalls(stub func(*models.Product) error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = stub
}

func (fake *FakeFormat) RenderVersionsArgsForCall(i int) *models.Product {
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	argsForCall := fake.renderVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFormat) RenderVersionsReturns(result1 error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = nil
	fake.renderVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) RenderVersionsReturnsOnCall(i int, result1 error) {
	fake.renderVersionsMutex.Lock()
	defer fake.renderVersionsMutex.Unlock()
	fake.RenderVersionsStub = nil
	if fake.renderVersionsReturnsOnCall == nil {
		fake.renderVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFormat) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.printHeaderMutex.RLock()
	defer fake.printHeaderMutex.RUnlock()
	fake.renderAssetsMutex.RLock()
	defer fake.renderAssetsMutex.RUnlock()
	fake.renderChartMutex.RLock()
	defer fake.renderChartMutex.RUnlock()
	fake.renderChartsMutex.RLock()
	defer fake.renderChartsMutex.RUnlock()
	fake.renderContainerImageMutex.RLock()
	defer fake.renderContainerImageMutex.RUnlock()
	fake.renderContainerImagesMutex.RLock()
	defer fake.renderContainerImagesMutex.RUnlock()
	fake.renderFileMutex.RLock()
	defer fake.renderFileMutex.RUnlock()
	fake.renderFilesMutex.RLock()
	defer fake.renderFilesMutex.RUnlock()
	fake.renderProductMutex.RLock()
	defer fake.renderProductMutex.RUnlock()
	fake.renderProductsMutex.RLock()
	defer fake.renderProductsMutex.RUnlock()
	fake.renderVersionsMutex.RLock()
	defer fake.renderVersionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFormat) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ output.Format = new(FakeFormat)
